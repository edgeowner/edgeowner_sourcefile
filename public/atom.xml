<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>edgeowner</title>
  
  <subtitle>多读书，读好书，少写bug</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://edgeowner.com/"/>
  <updated>2018-03-14T02:28:55.234Z</updated>
  <id>http://edgeowner.com/</id>
  
  <author>
    <name>ZhangSunny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java序列化</title>
    <link href="http://edgeowner.com/2018/03/13/Java%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://edgeowner.com/2018/03/13/Java序列化/</id>
    <published>2018-03-13T12:06:04.000Z</published>
    <updated>2018-03-14T02:28:55.234Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java" scheme="http://edgeowner.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://edgeowner.com/tags/Java/"/>
    
      <category term="Serialize" scheme="http://edgeowner.com/tags/Serialize/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO</title>
    <link href="http://edgeowner.com/2018/03/13/Java-NIO/"/>
    <id>http://edgeowner.com/2018/03/13/Java-NIO/</id>
    <published>2018-03-13T12:05:28.000Z</published>
    <updated>2018-03-14T02:35:31.573Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java LDAP</title>
    <link href="http://edgeowner.com/2018/03/13/Java-LDAP/"/>
    <id>http://edgeowner.com/2018/03/13/Java-LDAP/</id>
    <published>2018-03-13T12:05:05.000Z</published>
    <updated>2018-03-14T02:35:23.955Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java CAS</title>
    <link href="http://edgeowner.com/2018/03/13/Java-CAS/"/>
    <id>http://edgeowner.com/2018/03/13/Java-CAS/</id>
    <published>2018-03-13T12:04:50.000Z</published>
    <updated>2018-03-19T10:37:03.986Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>日常开发工具集（1）</title>
    <link href="http://edgeowner.com/2018/03/01/developing-tools/"/>
    <id>http://edgeowner.com/2018/03/01/developing-tools/</id>
    <published>2018-03-01T12:20:25.000Z</published>
    <updated>2016-03-01T13:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;日常工作中只要时方便开发的部分工具的用途及资源会在此文介绍，欢迎广大技术蜀黍添加。</p><h4 id="Java源代码搜索"><a href="#Java源代码搜索" class="headerlink" title="Java源代码搜索"></a>Java源代码搜索</h4><p>&emsp;&emsp;Grepcode(<a href="http://grepcode.com/" target="_blank" rel="noopener">资源地址</a>)是面向Java开发人员的网站，这里可通过Java的<font color="#FF8C69">project</font> 、<font color="#FF8C69">classes</font>等关键字在线查看它对应的源码，知道对应的<font color="#FF8C69">project</font>、<font color="#FF8C69">classes</font>等信息。更方便的是，能提供不同版本的源代码在线查看：<strong>jar包</strong> 、<strong>源码jar包</strong>、<strong>doc下载</strong>。同样，也可以使用xxx-1.1.1.jar类似这样的名字直接找到对应的jar包，从而下载。<br><img src="http://p5vswdxl9.bkt.clouddn.com/Grepcode.jpg" alt="Grepcode"></p><h4 id="开源代码以及文档搜索"><a href="#开源代码以及文档搜索" class="headerlink" title="开源代码以及文档搜索"></a>开源代码以及文档搜索</h4><p>&emsp;&emsp;SearchCode(<a href="https://searchcode.com/" target="_blank" rel="noopener">资源地址</a>)是一个源码搜索引擎，目前支持从<strong>Github</strong> 、<strong>Bitbucket</strong>、<strong>Google Code</strong>、<strong>CodePlex</strong>、<strong>SourceForge</strong> 和 <strong>Fedora Project</strong> 平台搜索公开的源码。<br><img src="http://p5vswdxl9.bkt.clouddn.com/searchcode.jpg" alt="Searchcode"></p><h4 id="电子书搜索"><a href="#电子书搜索" class="headerlink" title="电子书搜索"></a>电子书搜索</h4><p>&emsp;&emsp;鸠摩搜书(<a href="https://www.jiumodiary.com/" target="_blank" rel="noopener">资源地址</a>)是一个比较不错的电子书搜索网站。内容也比较全。<br><img src="http://p5vswdxl9.bkt.clouddn.com/jiumodiary.jpg" alt="Jiumodiary"></p><h4 id="网盘资源搜索"><a href="#网盘资源搜索" class="headerlink" title="网盘资源搜索"></a>网盘资源搜索</h4><p>&emsp;&emsp;盘搜(<a href="http://pansou.com" target="_blank" rel="noopener">资源地址</a>)可以通过这个网站搜索百度网盘上面的各种资源。<br><img src="http://p5vswdxl9.bkt.clouddn.com/Pansou.jpg" alt="Pansou"></p><h4 id="无版权图片搜索"><a href="#无版权图片搜索" class="headerlink" title="无版权图片搜索"></a>无版权图片搜索</h4><p>&emsp;&emsp;Unsplash(<a href="https://unsplash.com" target="_blank" rel="noopener">资源地址</a>)是我用过的最好的网站，不需要登录，图片很高请，也比较全。唯一的缺点就是需要英文搜搜<br><img src="http://p5vswdxl9.bkt.clouddn.com/unsplash.jpg" alt="Unsplash"></p><h4 id="在线UML制图"><a href="#在线UML制图" class="headerlink" title="在线UML制图"></a>在线UML制图</h4><p>&emsp;&emsp;ProcessOn(<a href="https://unsplash.com" target="_blank" rel="noopener">资源地址</a>)是一个在线协作绘图平台，为用户提供最强大、易用的作图工具!支持在线创作<strong>流程图</strong> 、<strong>BPMN</strong> 、<strong>UML图</strong> 、<strong>UI界面原型设计</strong>、<strong>iOS界面原型设计</strong>等。<br><img src="http://p5vswdxl9.bkt.clouddn.com/ProcessOn.jpg" alt="ProcessOn"></p><h4 id="Json在线验证及格式化"><a href="#Json在线验证及格式化" class="headerlink" title="Json在线验证及格式化"></a>Json在线验证及格式化</h4><p>&emsp;&emsp;json.cn(<a href="https://www.json.cn/" target="_blank" rel="noopener">资源地址</a>)是比较不错的，不仅支持Json格式的验证及格式化，还可以将Json格式压缩成普通文本等，以及查询Json组件和Json解析相关代码好用功能。<br><img src="http://p5vswdxl9.bkt.clouddn.com/json.cn.jpg" alt="Json.cn"></p><h4 id="json生成java类"><a href="#json生成java类" class="headerlink" title="json生成java类"></a>json生成java类</h4><p>&emsp;&emsp;bejson(<a href="http://www.bejson.com/json2javapojo/" target="_blank" rel="noopener">资源地址</a>Json是目前JavaWeb中数据传输的主要格式，很多时候会有把Json转成Java对象的需求。有时候合作方会提供一个Json的样例，需要我们自己定义Java类，这时候这个工具就派上用场了。<br><img src="http://p5vswdxl9.bkt.clouddn.com/bejson.jpg" alt="bejson"></p><h4 id="SQL自动生成Java代码"><a href="#SQL自动生成Java代码" class="headerlink" title="SQL自动生成Java代码"></a>SQL自动生成Java代码</h4><p>&emsp;&emsp;Json(<a href="http://www.autojcode.com/code/sql2class.jsp#" target="_blank" rel="noopener">资源地址</a>)是目前JavaWeb中数据传输的主要格式，很多时候会有把json转成Java对象的需求。有时候合作方会提供一个json的样例，需要我们自己定义Java类，这时候这个工具就派上用场了。<br><img src="http://p5vswdxl9.bkt.clouddn.com/AutoJcode.jpg" alt="AutoJCode.jpg"></p><h4 id="Maven依赖查询"><a href="#Maven依赖查询" class="headerlink" title="Maven依赖查询"></a>Maven依赖查询</h4><p>&emsp;&emsp;Mvnrepository(<a href="http://mvnrepository.com/" target="_blank" rel="noopener">资源地址</a>)查询开源的Java的jar包版本依赖标签<br><img src="http://p5vswdxl9.bkt.clouddn.com/maven.png" alt="mvnrepository"></p><h4 id="Cron表达式生成"><a href="#Cron表达式生成" class="headerlink" title="Cron表达式生成"></a>Cron表达式生成</h4><p>&emsp;&emsp;Pdtools(<a href="http://www.pdtools.net/tools/becron.jsp" target="_blank" rel="noopener">资源地址</a>)用于配置定时任务的cron表达式。<br><img src="http://p5vswdxl9.bkt.clouddn.com/cron.jpg" alt="cron"></p><h4 id="正则验证"><a href="#正则验证" class="headerlink" title="正则验证"></a>正则验证</h4><p>&emsp;&emsp;(<a href="http://tool.chinaz.com/regex" target="_blank" rel="noopener">资源地址</a>)Java开发对正则表达式肯定不陌生。站长工具提供的正则验证还不错。<br><img src="http://p5vswdxl9.bkt.clouddn.com/regex%281%29.jpg" alt=""></p><h4 id="正则代码生成"><a href="#正则代码生成" class="headerlink" title="正则代码生成"></a>正则代码生成</h4><p>&emsp;&emsp;(<a href="http://tool.chinaz.com/tools/regexgenerate" target="_blank" rel="noopener">资源地址</a>)站长工具提供的正则代码生成。可以一键生成身份证号、邮箱、手机号等验证的正则表达式。<br><img src="http://p5vswdxl9.bkt.clouddn.com/regex2.jpg" alt=""></p><h4 id="时间戳转换"><a href="#时间戳转换" class="headerlink" title="时间戳转换"></a>时间戳转换</h4><p>&emsp;&emsp;(<a href="http://tool.chinaz.com/Tools/unixtime.aspx" target="_blank" rel="noopener">资源地址</a>)时间戳(英语：Timestamp）是指在一连串的资料中加入辨识文字，如时间或日期，用以保障本地端（local）资料更新顺序与远端（remote）一致。<br>Java中很多地方都会用到时间戳，也经常会使用这种转换工具。<br><img src="http://p5vswdxl9.bkt.clouddn.com/timestamp.jpg" alt=""></p><h4 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h4><p>&emsp;&emsp;(<a href="http://tool.chinaz.com/tools/textencrypt.aspx" target="_blank" rel="noopener">资源地址</a>)加密解密也是JavaWeb可能会经常遇到的，有的时候我们需要验证加密算法是否正确，或者要解密等场景，就需要一个在线工具。<br><img src="http://p5vswdxl9.bkt.clouddn.com/md5.jpg" alt=""></p><h4 id="在线调色板"><a href="#在线调色板" class="headerlink" title="在线调色板"></a>在线调色板</h4><p>&emsp;&emsp;(<a href="http://link.fobshanghai.com/rgbcolor.htm" target="_blank" rel="noopener">资源地址</a>)常用MarkDown字体配色使用获取RGB代码例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"微软雅黑"</span> <span class="attr">color</span>=<span class="string">#9900ff</span> <span class="attr">size</span>=<span class="string">2</span>&gt;</span>-Xms1024m -Xmx1024m  -XX:PermSize=512M -XX:MaxPermSize=1024m  -Dfile.encoding=utf-8 <span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="http://p5vswdxl9.bkt.clouddn.com/tiaose.jpg" alt=""></p><h4 id="ASCII-ART生成"><a href="#ASCII-ART生成" class="headerlink" title="ASCII ART生成"></a>ASCII ART生成</h4><p>&emsp;&emsp;ASCII ART生成(<a href="http://patorjk.com/software/taag/" target="_blank" rel="noopener">资源地址</a>)<br><img src="http://p5vswdxl9.bkt.clouddn.com/ASCII%20ART.jpg" alt=""></p><h4 id="常用对照表"><a href="#常用对照表" class="headerlink" title="常用对照表"></a>常用对照表</h4><ol><li><a href="http://tool.oschina.net/commons?type=4" target="_blank" rel="noopener">ASCII对照表</a></li><li><a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="noopener">HTTP状态码</a></li><li><a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">HTTP Content-type</a></li><li><a href="http://tool.oschina.net/commons?type=7" target="_blank" rel="noopener">TCP/UDP常见端口参考</a></li><li><a href="http://tool.oschina.net/commons?type=2" target="_blank" rel="noopener">HTML转义字符</a></li><li><a href="http://tool.oschina.net/commons?type=3" target="_blank" rel="noopener">RGB颜色参考</a></li><li><a href="http://tool.oschina.net/commons?type=8" target="_blank" rel="noopener">网页字体参考</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;日常工作中只要时方便开发的部分工具的用途及资源会在此文介绍，欢迎广大技术蜀黍添加。&lt;/p&gt;
&lt;h4 id=&quot;Java源代码搜索&quot;&gt;&lt;a href=&quot;#Java源代码搜索&quot; class=&quot;headerlink&quot; title=&quot;Java源代码搜索&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="开发工具集" scheme="http://edgeowner.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
    
      <category term="tools" scheme="http://edgeowner.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引介绍</title>
    <link href="http://edgeowner.com/2017/05/06/mysql-index/"/>
    <id>http://edgeowner.com/2017/05/06/mysql-index/</id>
    <published>2017-05-06T11:23:43.000Z</published>
    <updated>2017-05-06T13:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000012773157" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000012773157&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="示例代码" scheme="http://edgeowner.com/categories/%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Code" scheme="http://edgeowner.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://edgeowner.com/2017/05/06/SingletonPattern/"/>
    <id>http://edgeowner.com/2017/05/06/SingletonPattern/</id>
    <published>2017-05-06T10:23:43.000Z</published>
    <updated>2017-05-06T13:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">单例模式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.runoob.com/design-pattern/singleton-pattern.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;单例模式&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="示例代码" scheme="http://edgeowner.com/categories/%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Code" scheme="http://edgeowner.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>数据库的锁</title>
    <link href="http://edgeowner.com/2016/11/06/dateSourceLock/"/>
    <id>http://edgeowner.com/2016/11/06/dateSourceLock/</id>
    <published>2016-11-06T12:20:43.000Z</published>
    <updated>2016-11-06T13:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.hollischuang.com/archives/909" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.hollischuang.com/archives/909&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="并发控制相关知识点" scheme="http://edgeowner.com/categories/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="并发控制" scheme="http://edgeowner.com/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
      <category term="锁" scheme="http://edgeowner.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>浅析数据库读现象</title>
    <link href="http://edgeowner.com/2016/11/05/dataSourceRead/"/>
    <id>http://edgeowner.com/2016/11/05/dataSourceRead/</id>
    <published>2016-11-05T02:20:28.000Z</published>
    <updated>2016-11-05T02:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.hollischuang.com/archives/900" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.hollischuang.com/archives/900&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="并发控制相关知识点" scheme="http://edgeowner.com/categories/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="并发控制" scheme="http://edgeowner.com/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
      <category term="锁" scheme="http://edgeowner.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁与悲观锁的实际应用</title>
    <link href="http://edgeowner.com/2016/10/01/optimistic-pessimistic/"/>
    <id>http://edgeowner.com/2016/10/01/optimistic-pessimistic/</id>
    <published>2016-10-01T11:20:43.000Z</published>
    <updated>2016-10-01T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="高并发场景"><a href="#高并发场景" class="headerlink" title="高并发场景"></a>高并发场景</h4><p>&emsp;&emsp;首先假设一个业务场景：数据库中有一条数据，需要获取到当前的值，在当前值的基础上$+10$，然后再更新回去。如果此时有两个线程同时并发处理，第一个线程拿到数据是$10，+10=20$更新回去。第二个线程原本是要在第一个线程的基础上再$+20=40$,结果由于并发访问取到更新前的数据为$10，+20=30$。<br>这就是典型的存在中间状态，导致数据不正确。来看以下的例子：<br>并发所带来的问题，和上文提到的类似，这里有一张price表，表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`price`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`total`</span> <span class="built_in">decimal</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'总值'</span>,</span><br><span class="line">  <span class="string">`front`</span> <span class="built_in">decimal</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'消费前'</span>,</span><br><span class="line">  <span class="string">`end`</span> <span class="built_in">decimal</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'消费后'</span>,</span><br><span class="line">  <span class="string">`add_time`</span> <span class="keyword">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'添加时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="keyword">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>, <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure><a id="more"></a><p>单测例子如下(<a href="">Github代码地址</a>)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就一个主线程，循环100次，每次把front的值减去10，再写入一次流水记录，正常情况是写入的每条记录都会每次减去10。</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleCounsumerTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Price price = priceMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> ron = <span class="number">10</span>;</span><br><span class="line">            price.setFront(price.getFront().subtract(<span class="keyword">new</span> BigDecimal(ron)));</span><br><span class="line">            price.setEnd(price.getEnd().add(<span class="keyword">new</span> BigDecimal(ron)));</span><br><span class="line">            price.setTotal(price.getFront().add(price.getEnd()));</span><br><span class="line"></span><br><span class="line">            priceMapper.updateByPrimaryKey(price);</span><br><span class="line">            price.setId(<span class="keyword">null</span>);</span><br><span class="line">            priceMapper.insertSelective(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行结果如下图：<br><img src="http://p5vswdxl9.bkt.clouddn.com/result1.png" alt="图（1）"><br>可以看到确实是每次都递减10，但是如果是多线程的情况下会是如何呢？（<a href="https://github.com/edgeowner/saber" target="_blank" rel="noopener">代码PriceController</a>）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/price"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PriceApplication priceApplication;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PriceMapper priceMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolConfig config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多线程并发执行Demo ,无锁场景下的更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priceVO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/update"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; updatePrice(<span class="meta">@RequestBody</span> PriceVO priceVO) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (priceVO == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BizException(BizException.NUM_VALIDATION, <span class="string">"priceVO is null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        toUpdatePrice(count);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                config.submit(thread);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> WebUtil.success(<span class="string">"price更新成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BizException ex) &#123;</span><br><span class="line">            log.error(<span class="string">"更新价格失败"</span>, ExceptionUtils.getFullStackTrace(ex));</span><br><span class="line">            <span class="keyword">return</span> WebUtil.error(ex.getErrorMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toUpdatePrice</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        log.info(MessageFormat.format(<span class="string">"thread create start:&#123;0&#125; "</span>, count));</span><br><span class="line">        Price price = priceMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ron = <span class="number">10</span>;</span><br><span class="line">        price.setFront(price.getFront().subtract(<span class="keyword">new</span> BigDecimal(ron)));</span><br><span class="line">        price.setEnd(price.getEnd().add(<span class="keyword">new</span> BigDecimal(ron)));</span><br><span class="line">        priceMapper.updateByPrimaryKey(price);</span><br><span class="line">        price.setId(<span class="keyword">null</span>);</span><br><span class="line">        priceMapper.insertSelective(price);</span><br><span class="line">        log.info(MessageFormat.format(<span class="string">"thread create end:&#123;0&#125; "</span>, count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于线程池的使用今后会仔细探讨。这里就简单理解为有10个线程并发去处理上面单线程的逻辑，来看看结果怎么样？<br><img src="http://p5vswdxl9.bkt.clouddn.com/result2.png" alt="图（2）"></p><p>会看到明显的数据错误，导致错误的原因自然就是有线程读取到了中间状态进行了错误的更新。<br>进而有了以下两种解决方案：<strong><em>悲观锁 </em></strong>和<strong><em>乐观锁 </em></strong>。</p><hr><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>&emsp;&emsp;简单理解下悲观锁：当一个事务锁定了一些数据之后，只有当当前锁提交了事务，释放了锁，其他事务才能获得锁并执行操作。<br>使用方式如下：<br>首先要关闭MySQL的自动提交：set autocommit = 0;<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bigen <span class="comment">--开启事务</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, total, front, <span class="keyword">end</span> <span class="keyword">from</span> price <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> price <span class="keyword">values</span>(?,?,?,?,?)</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> <span class="comment">--提交事务</span></span><br></pre></td></tr></table></figure></p><p>这里使用<strong>select for update</strong>的方式利用数据库开启了悲观锁，锁定了id=1的这条数据(注意：<strong>这里除非是使用了索引会启用行级锁，不然是会使用表锁，将整张表都锁住。</strong>)。之后使用commit提交事务并释放锁，这样下一个线程过来拿到的就是正确的数据。<br>悲观锁一般是用于并发不是很高，并且不允许脏读等情况。但是对数据库资源消耗较大。</p><hr><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>&emsp;&emsp;乐观锁是首先假设数据冲突很少，只有在数据提交修改的时候才进行校验，如果冲突了则不会进行更新。<br>通常的实现方式增加一个version字段，为每一条数据加上版本。每次更新的时候version+1，并且更新时候带上版本号。实现方式如下：<br>新建了一张price_version表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`price_version`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`total`</span> <span class="built_in">decimal</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'总值'</span>,</span><br><span class="line">  <span class="string">`front`</span> <span class="built_in">decimal</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'消费前'</span>,</span><br><span class="line">  <span class="string">`end`</span> <span class="built_in">decimal</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'消费后'</span>,</span><br><span class="line">  <span class="string">`version`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'并发版本控制'</span>,</span><br><span class="line">  <span class="string">`add_time`</span> <span class="keyword">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>  <span class="keyword">COMMENT</span> <span class="string">'添加时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="keyword">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>  <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure></p><p><code>更新数据的SQL</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateByVersion"</span> <span class="attr">parameterType</span>=<span class="string">"com.demo.saber.infrastructure.po.PriceVersion"</span>&gt;</span></span><br><span class="line">        update price_version</span><br><span class="line">        set front = #&#123;front, jdbcType=DECIMAL&#125;,</span><br><span class="line">            version = version + 1</span><br><span class="line">        where id = #&#123;id, jdbcType=INTEGER&#125;</span><br><span class="line">        and version = #&#123;version, jdbcType=INTEGER&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>调用方式</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/priceverion"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceVersionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PriceVersionMapper priceVersionMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolConfig config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多线程并发执行Demo ,乐观锁场景下的更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priceVersionVO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/threadPriceVersion"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; updatePrice(<span class="meta">@RequestBody</span> PriceVersionVO priceVersionVO) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (priceVersionVO == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BizException(BizException.NUM_VALIDATION, <span class="string">"priceVersionVO is null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        PriceVersion priceVersion = priceVersionMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">int</span> ron = <span class="number">10</span>;</span><br><span class="line">                        <span class="comment">//"本次消费=" + ron</span></span><br><span class="line">                        log.info(MessageFormat.format(<span class="string">"当前线程(&#123;0&#125;)本次消费=&#123;1&#125;"</span>, count, ron));</span><br><span class="line">                        priceVersion.setFront(<span class="keyword">new</span> BigDecimal(ron));</span><br><span class="line">                        <span class="keyword">int</span> backflag = priceVersionMapper.updateByVersion(priceVersion);</span><br><span class="line">                        <span class="keyword">if</span> (backflag == <span class="number">0</span>) &#123;</span><br><span class="line">                            log.error(MessageFormat.format(<span class="string">"当前线程(&#123;0&#125;)更新失败"</span>, count));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            log.error(MessageFormat.format(<span class="string">"当前线程(&#123;0&#125;)更新成功"</span>, count));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                config.submit(thread);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> WebUtil.success(<span class="string">"priceVersion更新成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BizException ex) &#123;</span><br><span class="line">            log.error(<span class="string">"更新priceVersion失败"</span>, ExceptionUtils.getFullStackTrace(ex));</span><br><span class="line">            <span class="keyword">return</span> WebUtil.error(ex.getErrorMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>处理逻辑 </strong>：开了三个线程生成了20以内的随机数更新到front字段。调用该接口时日志如下：<br><img src="http://p5vswdxl9.bkt.clouddn.com/result3.jpg" alt="更新日志"><br>可以看到线程1、2、3、4都更新失败了，线程0更新成功了。</p><p>乐观锁在实际应用相对较多，它可以提供更好的并发访问，并且数据库开销较少，但是有可能存在脏读的情况。</p><hr><h4 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h4><p><a href="https://github.com/edgeowner/saber" target="_blank" rel="noopener">edgeowner</a></p><h4 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h4><p><a href="https://juejin.im/post/5962e64c6fb9a06ba14b9cd9" target="_blank" rel="noopener">SSM (十五) 乐观锁与悲观锁的实际应用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;高并发场景&quot;&gt;&lt;a href=&quot;#高并发场景&quot; class=&quot;headerlink&quot; title=&quot;高并发场景&quot;&gt;&lt;/a&gt;高并发场景&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;首先假设一个业务场景：数据库中有一条数据，需要获取到当前的值，在当前值的基础上$+10$，然后再更新回去。如果此时有两个线程同时并发处理，第一个线程拿到数据是$10，+10=20$更新回去。第二个线程原本是要在第一个线程的基础上再$+20=40$,结果由于并发访问取到更新前的数据为$10，+20=30$。&lt;br&gt;这就是典型的存在中间状态，导致数据不正确。来看以下的例子：&lt;br&gt;并发所带来的问题，和上文提到的类似，这里有一张price表，表结构如下：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`price`&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; AUTO_INCREMENT &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;主键&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`total`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;decimal&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;0.00&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;总值&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`front`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;decimal&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;0.00&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;消费前&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`end`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;decimal&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;0.00&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;消费后&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`add_time`&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;timestamp&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;添加时间&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`update_time`&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;timestamp&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;更新时间&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) &lt;span class=&quot;keyword&quot;&gt;ENGINE&lt;/span&gt;=&lt;span class=&quot;keyword&quot;&gt;InnoDB&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;CHARSET&lt;/span&gt;=utf8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="并发控制相关知识点" scheme="http://edgeowner.com/categories/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="并发控制" scheme="http://edgeowner.com/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
      <category term="锁" scheme="http://edgeowner.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>事务知识点</title>
    <link href="http://edgeowner.com/2016/10/01/tranaction/"/>
    <id>http://edgeowner.com/2016/10/01/tranaction/</id>
    <published>2016-10-01T11:20:43.000Z</published>
    <updated>2016-10-01T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>&emsp;&emsp;本文主要介绍事务的相关知识点，同时也为后续讲解乐观锁和悲观锁作铺垫，先对以下事务相关的知识点：<code>ACID</code>、<code>事物的常见问题</code>以及<code>事务的隔离级别</code>先做介绍，至于<code>锁</code>后续会有专题详细介绍。<br>事务就是一组原子性的sql，或者一个独立的工作单元，事务可以就Mysql引擎来说的话就是要么全部执行这一组sql语句（CURD组合），要么全部都不执行（比如其中一条语句失败会导致这一组语句全部失败）。<br>事务是并发控制的单元，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位，说白了就是为了保证系统始终处于一个完整且正确的状态。</p><a id="more"></a><hr><h4 id="事务特性：ACID"><a href="#事务特性：ACID" class="headerlink" title="事务特性：ACID"></a>事务特性：ACID</h4><p>事务的ACID特性：</p><h5 id="A：Atomiciy-原子性-："><a href="#A：Atomiciy-原子性-：" class="headerlink" title="A：Atomiciy(原子性)："></a>A：Atomiciy(原子性)：</h5><p>一个事物必须保证其中的操作要么全部执行，要么全部回滚，不可能存在只执行了一部分这种情况出现。简单说就是事务是一个不可分隔的工作单位，事务中的操作要么都发生，要么都不发生；</p><p>事务包含的全部操作是一个不可分割的整体，要么全部执行，要么全部都不执行。</p><h5 id="C：Consistency-一致性-："><a href="#C：Consistency-一致性-：" class="headerlink" title="C：Consistency(一致性)："></a>C：Consistency(一致性)：</h5><p>数据必须保证从一种一致性的状态转换为另一种一致性状态。也就是事务开始到结束的时间段内，事务前后数据的完整性必须保证一致；  </p><p>例如：事务之前A,B两个账户的总和是10万(A:4W,B:6W),现在A转账B2万(A:2W,B:8W),A,B账户总和依旧应该是10万，如果不是10万的话，则事务前后对于账户总和这种资源是不一致的。</p><h5 id="I：Isolation-隔离性-："><a href="#I：Isolation-隔离性-：" class="headerlink" title="I：Isolation(隔离性)："></a>I：Isolation(隔离性)：</h5><p>在一个事物未执行完毕时，通常会保证其他Session无法看到这个事务的执行结果。也就是说多个用户并发访问数据库时，一个用户的事物不能被其他用户的事物所干扰，多个并发事务之间数据要相互隔离。数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的”独立”环境执行；</p><p>主要规定了各个事务之间相互影响的程度，主要用于规定多个事务访问同一数据资源，各个事务对该数据资源访问的行为。</p><h5 id="D：Durability-持久性-："><a href="#D：Durability-持久性-：" class="headerlink" title="D：Durability(持久性)："></a>D：Durability(持久性)：</h5><p>事务一旦commit，则数据就会保存下来，即使提交完之后系统崩溃，数据也不会丢失。</p><p>事务一旦完成，要将数据所做的变更记录下来(冗余存储或多数据网络备份)。</p><hr><h4 id="事务常见问题"><a href="#事务常见问题" class="headerlink" title="事务常见问题"></a>事务常见问题</h4><h5 id="更新丢失-Lost-Update-："><a href="#更新丢失-Lost-Update-：" class="headerlink" title="更新丢失(Lost Update)："></a><code>更新丢失(Lost Update)</code>：</h5><ol><li>场景：假定两个事物有$A$和$B$，事务$A$和事物$B$同时获得相同的数据，然后在各自的事物中修改数据M，事先$A$先提交事物，数据M假如为$M+$，事务$B$后提交事物，数据$M$变成了$M++$，最终结果变成$M++$，覆盖了事物$A$的更新。  </li><li>原因：当多个事务选择同一行操作，并且都是基于最初选定的值，由于每个事务都不知道其他事务的存在，就会发生更新覆盖的问题。类比Github提交冲突。  </li><li>例子：   </li></ol><div class="table-container"><table><thead><tr><th>事物$A$</th><th>事物$B$</th></tr></thead><tbody><tr><td>读取 $X=100$</td><td>读取 $X=100$</td></tr><tr><td>写入 $X=X+100$</td><td></td></tr><tr><td>事物结束 $X = 200$</td><td></td></tr><tr><td></td><td>写入 $X =X+100$</td></tr><tr><td></td><td>事物结束 $X=300$(事物A的数据更新丢失)</td></tr></tbody></table></div><h5 id="脏读-Dirty-Reads-："><a href="#脏读-Dirty-Reads-：" class="headerlink" title="脏读(Dirty Reads)："></a><code>脏读(Dirty Reads)</code>：</h5><ol><li>场景：<strong>允许事物B可以读到事物A修改而未提交的数据</strong>，<strong>可能</strong>会造成脏读（脏读本质就是无效数据，只有当事物$A$回滚，那么事物B读到的数据才为无效的，所以这里只是<strong>可能</strong>造成脏读，当事物$A$不回滚的时候，事物$B$读到的数据就不为脏数据，也就是有效的数据，脏数据会导致以后的操作都会发生错误，一定要避免，不能凭借侥幸，事物$A$不能百分之百保证不回滚，所以<strong>这种隔离级别很少用于实际应用</strong>，并且它的性能也不比其他借笔好）。</li><li>原因：事物B读取了事物$A$已经修改但尚未提交的数据。若事物$A$回滚数据，事物$A$的数据存在不一致性的问题。</li><li>例子：</li></ol><div class="table-container"><table><thead><tr><th>事物$A$</th><th>事物$B$</th></tr></thead><tbody><tr><td>写入 $X=X+100(x=200)$</td><td></td></tr><tr><td></td><td>读取 $X=200$(无效数据，脏读)</td></tr><tr><td>事务回滚 $X=100$</td><td></td></tr><tr><td>事务结束 $X=100$</td><td></td></tr><tr><td></td><td>事务结束</td></tr></tbody></table></div><h5 id="不可重复读-Non-Repeatable-Reads-："><a href="#不可重复读-Non-Repeatable-Reads-：" class="headerlink" title="不可重复读(Non-Repeatable Reads)："></a><code>不可重复读(Non-Repeatable Reads)</code>：</h5><ol><li>场景：不可重复读是指在一个事务范围中$2$次或者多次查询同一数据$M$返回了不同的数据，例如：事务$B$读取某一数据，事务$A$修改了该数据$M$并且提交，事务$B$又读取该数据$M$(可能是再次校验)，在同一个事务$B$中，读取同一个数据$M$的结果集不同。</li><li>原因：事物$B$第一次读取最初数据，第二次读取事物A已经提交的修改或删除数据。导致两次读取数据不一致。不符合事物的隔离性。</li><li>例子：</li></ol><div class="table-container"><table><thead><tr><th>事物$A$</th><th>事物$B$</th></tr></thead><tbody><tr><td>读取 $X=100$</td><td>读取 $X=100$</td></tr><tr><td>写入 $X=X+100$</td><td>读取 $X=100$</td></tr><tr><td>事务结束，$X=200$</td><td></td></tr><tr><td></td><td>读取 $X=200$(在一个事务B中读X的值发生了变化)</td></tr><tr><td></td><td>事物结束</td></tr></tbody></table></div><h5 id="幻读-Phantom-Reads-："><a href="#幻读-Phantom-Reads-：" class="headerlink" title="幻读(Phantom Reads)："></a><code>幻读(Phantom Reads)</code>：</h5><ol><li>当用户读取某一个范围的数据行时，另一个事物又在该范围内查询了新行，当用户再读取该范围的数据行时，会发现会有新的“幻影行”，例如：事物$B$读到某一个数据$M$，事物$A$对数据$M$增加了一行并提交，事物$B$又读数据$M$，发生多出了一行造成的结果不一致(如果行数相同，则是不可重复读)。   </li><li>原因：事物$B$根据相同的条件第二次查询到事物$A$提交的新增数据，两次数据结果集不一致。不符合事物的隔离性。</li><li>例子：在事物$B$里，同一个数据集$M$，读到的条数不一致(新增，删除)。</li></ol><div class="table-container"><table><thead><tr><th>事务$A$</th><th>事务$B$</th></tr></thead><tbody><tr><td></td><td>读取数据集$M$(3行)</td></tr><tr><td>在数据集$M$插入一行(4行)</td><td></td></tr><tr><td>事务结束</td><td></td></tr><tr><td></td><td>读取数据$M$(4行)</td></tr><tr><td></td><td>事务结束</td></tr></tbody></table></div><hr><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><p>数据库的事物隔离越严格，并发副作用越小，但付出的代价也就越大。因为事务隔离实质上是将事务在一定程度上“串行”进行，这显然与“并发”是矛盾的。实际业务中处理的话，根据自己的业务逻辑，权衡能接受的最大副作用，从而平衡了<strong><em>“隔离” </em></strong>和<strong><em>“并发” </em></strong>的问题。Mysql默认隔离级别是可重复读的。<br>事务的隔离级别通常有四种（RU, RC, RR，Serializable）：</p><div class="table-container"><table><thead><tr><th>隔离级别</th><th>读数据一致性</th><th>脏读可能性</th><th>不可重复读可能性</th><th>幻读可能性</th><th>加锁读</th></tr></thead><tbody><tr><td>未提交读(Read uncommitted)</td><td>最低级别</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>已提交读(Read committed)</td><td>语句级别</td><td>N</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>可重复读(Repeatable read)</td><td>事务级别</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>可序列化(Serializable)</td><td>最高级别，事务级别</td><td>N</td><td>N</td><td>N</td><td>Y</td></tr></tbody></table></div><hr><h4 id="MySql常用命令"><a href="#MySql常用命令" class="headerlink" title="MySql常用命令"></a>MySql常用命令</h4><h5 id="查询隔离级别"><a href="#查询隔离级别" class="headerlink" title="查询隔离级别"></a>查询隔离级别</h5><p>select @@tx_isolation;</p><h5 id="设置手动提交"><a href="#设置手动提交" class="headerlink" title="设置手动提交"></a>设置手动提交</h5><p>set autocommit=0 ;</p><h5 id="查看当前事务自动提交模式"><a href="#查看当前事务自动提交模式" class="headerlink" title="查看当前事务自动提交模式"></a>查看当前事务自动提交模式</h5><p>select @@autocommit;</p><h5 id="设置隔离级别"><a href="#设置隔离级别" class="headerlink" title="设置隔离级别"></a>设置隔离级别</h5><p>set tx_isolation = ‘READ-COMMITTED’;</p><h5 id="查询表的状态"><a href="#查询表的状态" class="headerlink" title="查询表的状态"></a>查询表的状态</h5><p>show table status like ‘test1’;</p><h5 id="修改表的存储引擎"><a href="#修改表的存储引擎" class="headerlink" title="修改表的存储引擎"></a>修改表的存储引擎</h5><p>alter table test1 engine = INNODB</p><h5 id="查看是否开启日志"><a href="#查看是否开启日志" class="headerlink" title="查看是否开启日志"></a>查看是否开启日志</h5><p>show variables like ‘log_bin’;</p><h5 id="查看日志状态"><a href="#查看日志状态" class="headerlink" title="查看日志状态"></a>查看日志状态</h5><p>show master status;</p><hr><h4 id="相关技术参考："><a href="#相关技术参考：" class="headerlink" title="相关技术参考："></a>相关技术参考：</h4><p><a href="https://segmentfault.com/a/1190000004437223" target="_blank" rel="noopener">深入浅出事务（1）</a><br><a href="https://segmentfault.com/a/1190000004437275" target="_blank" rel="noopener">深入浅出事务（2）</a><br><a href="https://segmentfault.com/a/1190000004469395" target="_blank" rel="noopener">深入浅出事务（3）</a><br><a href="https://segmentfault.com/a/1190000012773157" target="_blank" rel="noopener">MySQL表锁和行锁机制</a><br><a href="https://juejin.im/post/5ab5e44a6fb9a028c97a013d" target="_blank" rel="noopener">Mysql之锁与事务</a><br><a href="https://segmentfault.com/a/1190000013122242" target="_blank" rel="noopener">数据库 - 事务管理（ACID）、隔离级别、事务传播行为</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;本文主要介绍事务的相关知识点，同时也为后续讲解乐观锁和悲观锁作铺垫，先对以下事务相关的知识点：&lt;code&gt;ACID&lt;/code&gt;、&lt;code&gt;事物的常见问题&lt;/code&gt;以及&lt;code&gt;事务的隔离级别&lt;/code&gt;先做介绍，至于&lt;code&gt;锁&lt;/code&gt;后续会有专题详细介绍。&lt;br&gt;事务就是一组原子性的sql，或者一个独立的工作单元，事务可以就Mysql引擎来说的话就是要么全部执行这一组sql语句（CURD组合），要么全部都不执行（比如其中一条语句失败会导致这一组语句全部失败）。&lt;br&gt;事务是并发控制的单元，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位，说白了就是为了保证系统始终处于一个完整且正确的状态。&lt;/p&gt;
    
    </summary>
    
      <category term="并发控制相关知识点" scheme="http://edgeowner.com/categories/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="事务" scheme="http://edgeowner.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁和悲观锁(OCC和PCC)</title>
    <link href="http://edgeowner.com/2016/10/01/optimistic-pessimistic-locking/"/>
    <id>http://edgeowner.com/2016/10/01/optimistic-pessimistic-locking/</id>
    <published>2016-10-01T11:20:43.000Z</published>
    <updated>2016-10-01T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本文在介乐观锁和悲观锁之前请先了解<a href="http://edgeowner.com/2016/10/01/tranaction/">事务相关知识点</a>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。<br>&emsp;&emsp;无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。<br>&emsp;&emsp;针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。</p><hr><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h4 id="乐观锁（Optimistic-Concurrency-Control，OCC）："><a href="#乐观锁（Optimistic-Concurrency-Control，OCC）：" class="headerlink" title="乐观锁（Optimistic Concurrency Control，OCC）："></a>乐观锁（Optimistic Concurrency Control，OCC）：</h4><h5 id="乐观锁的定义："><a href="#乐观锁的定义：" class="headerlink" title="乐观锁的定义："></a>乐观锁的定义：</h5><ul><li>1.在关系数据库管理系统里，乐观锁指的是一种并发控制的方法，又名“乐观锁”(Optimistic Concurrency Control)，缩写“OCC”，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</li><li>2.乐观锁(Optimistic Locking)相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</li><li>3.相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</li></ul><h5 id="乐观锁的流程："><a href="#乐观锁的流程：" class="headerlink" title="乐观锁的流程："></a>乐观锁的流程：</h5><ul><li>1.数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。</li><li>2.对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较和替换这两个动作作为一个原子操作尝试去修改内存中的变量，若失败则表示发生冲突，那么就应该有相应的重试逻辑。</li></ul><h5 id="悲观锁Demo演示："><a href="#悲观锁Demo演示：" class="headerlink" title="悲观锁Demo演示："></a>悲观锁Demo演示：</h5><ul><li><p>1.实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。使用版本号实现乐观锁：使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行$+1$操作。并判断当前版本号是不是该数据的最新的版本号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#Demo 1.0</span><br><span class="line">1.查询出商品信息</span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">status</span>,<span class="keyword">status</span>,<span class="keyword">version</span>) <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span>=#&#123;<span class="keyword">id</span>&#125;</span><br><span class="line"><span class="number">2.</span>根据商品信息生成订单</span><br><span class="line"><span class="number">3.</span>修改商品<span class="keyword">status</span>为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> t_goods </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span>=#&#123;<span class="keyword">id</span>&#125; <span class="keyword">and</span> <span class="keyword">version</span>=#&#123;<span class="keyword">version</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>2.对于并发间操作产生的线程安全问题持悲状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，直接上了锁就操作资源</li></ul></li></ul><h5 id="悲观锁的优点和不足："><a href="#悲观锁的优点和不足：" class="headerlink" title="悲观锁的优点和不足："></a>悲观锁的优点和不足：</h5><p>&emsp;&emsp;乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p><hr><h4 id="悲观锁（Pessimistic-Concurrency-Control，PCC）："><a href="#悲观锁（Pessimistic-Concurrency-Control，PCC）：" class="headerlink" title="悲观锁（Pessimistic Concurrency Control，PCC）："></a>悲观锁（Pessimistic Concurrency Control，PCC）：</h4><h5 id="悲观锁的定义："><a href="#悲观锁的定义：" class="headerlink" title="悲观锁的定义："></a>悲观锁的定义：</h5><ul><li>1.悲观锁指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）；</li><li>2.关系型数据库里，<strong>悲观并发控制</strong>是一种并发控制的方法。它可以阻止一个事物以影响其他用户的方式来修改数据。如果一个事物执行的操作都某行数据应用了锁，那只有当这个事物把锁释放，其他事物才能执行与该锁冲突的操作。</li></ul><h5 id="悲观锁的流程："><a href="#悲观锁的流程：" class="headerlink" title="悲观锁的流程："></a>悲观锁的流程：</h5><ul><li>1.悲观锁的流程：在对任意记录进行修改前，先尝试为该记录加上<a href="http://www.hollischuang.com/archives/923" target="_blank" rel="noopener">排他锁(exclusive locking)</a>，如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁，期间若有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li></ul><h5 id="悲观锁Demo演示：-1"><a href="#悲观锁Demo演示：-1" class="headerlink" title="悲观锁Demo演示："></a>悲观锁Demo演示：</h5><ul><li>1.Mysql InnoDB使用悲观锁：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#Demo 1.0</span><br><span class="line">//0.开始事务</span><br><span class="line"><span class="keyword">begin</span>;/<span class="keyword">begin</span> <span class="keyword">work</span>;/<span class="keyword">start</span> <span class="keyword">transaction</span>; (三者选一就可以)</span><br><span class="line">//1.查询出商品信息</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">//2.根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_orders (<span class="keyword">id</span>,goods_id) <span class="keyword">values</span> (<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line">//3.修改商品status为2</span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>;</span><br><span class="line">//4.提交事务</span><br><span class="line"><span class="keyword">commit</span>;/<span class="keyword">commit</span> <span class="keyword">work</span>;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;上面的查询语句中，我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。<br>  <strong><em>使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意 </em></strong>。<br>  简单理解下悲观锁：当一个事务锁定了一些数据之后，只有当当前锁提交了事务，释放了锁，其他事务才能获得锁并执行操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事物的成本环境中。</p><ul><li>2.下面另外一个简单Demo使用方式如下：<br>   首先要关闭MySQL的自动提交：set autocommit = 0;     <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Demo 2.0</span><br><span class="line"><span class="keyword">begin</span> <span class="comment">--开启事务</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, total, front, <span class="keyword">end</span> <span class="keyword">from</span> price <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> price <span class="keyword">values</span>(?,?,?,?,?)</span><br><span class="line"><span class="keyword">commit</span> <span class="comment">--提交事务</span></span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;这里使用<strong>select for update的方式</strong>利用数据库开启了悲观锁，锁定了id=1的这条数据(<strong><em>注意:这里除非是使用了索引会启用行级锁，不然是会使用表锁，将整张表都锁住。 </em></strong>)。之后使用commit提交事务并释放锁，这样下一个线程过来拿到的就是正确的数据。<br>悲观锁一般是用于并发不是很高，并且不允许脏读等情况。但是对数据库资源消耗较大。</p><h5 id="悲观锁的优点和不足：-1"><a href="#悲观锁的优点和不足：-1" class="headerlink" title="悲观锁的优点和不足："></a>悲观锁的优点和不足：</h5><p>&emsp;&emsp;悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数.</p><hr><h4 id="相关技术参考："><a href="#相关技术参考：" class="headerlink" title="相关技术参考："></a>相关技术参考：</h4><ol><li><a href="https://juejin.im/post/5962e64c6fb9a06ba14b9cd9" target="_blank" rel="noopener">乐观锁与悲观锁的实际应用</a>(<strong>推荐此文</strong>)</li><li><a href="https://segmentfault.com/a/1190000008935924" target="_blank" rel="noopener">MySQL乐观锁在分布式场景下的实践</a>(<strong>推荐此文</strong>)</li><li><a href="http://www.digpage.com/lock.html" target="_blank" rel="noopener">乐观锁与悲观锁</a></li><li><a href="http://www.hollischuang.com/archives/934" target="_blank" rel="noopener">深入理解乐观锁与悲观锁</a></li><li><a href="http://www.importnew.com/21037.html" target="_blank" rel="noopener">深入理解乐观锁与悲观锁</a></li><li><a href="https://www.cnblogs.com/deliver/p/5730616.html" target="_blank" rel="noopener">mysql的锁—行锁，表锁，乐观锁，悲观锁</a></li><li><a href="http://www.hollischuang.com/archives/909" target="_blank" rel="noopener">数据库的锁机制</a></li></ol><h4 id="本文代码Demo："><a href="#本文代码Demo：" class="headerlink" title="本文代码Demo："></a>本文代码Demo：</h4><p>Github地址：<a href="git@github.com:edgeowner/saber.git">参见Price相关代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;本文在介乐观锁和悲观锁之前请先了解&lt;a href=&quot;http://edgeowner.com/2016/10/01/tranaction/&quot;&gt;事务相关知识点&lt;/a&gt;乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。&lt;br&gt;&amp;
      
    
    </summary>
    
      <category term="并发控制相关知识点" scheme="http://edgeowner.com/categories/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="并发控制" scheme="http://edgeowner.com/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
      <category term="锁" scheme="http://edgeowner.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题目集锦 (1)</title>
    <link href="http://edgeowner.com/2016/06/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E9%9B%86%E9%94%A6/"/>
    <id>http://edgeowner.com/2016/06/01/Java面试题目集锦/</id>
    <published>2016-06-01T12:21:37.000Z</published>
    <updated>2018-03-14T02:35:47.142Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java面试题目汇总" scheme="http://edgeowner.com/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    
    
      <category term="Java" scheme="http://edgeowner.com/tags/Java/"/>
    
      <category term="面试题" scheme="http://edgeowner.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(4)</title>
    <link href="http://edgeowner.com/2016/04/27/jvm-introduce/"/>
    <id>http://edgeowner.com/2016/04/27/jvm-introduce/</id>
    <published>2016-04-27T09:00:00.000Z</published>
    <updated>2016-04-27T11:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>&emsp;&emsp;JVM内存结构主要有三大块：<strong><em>堆内存</em></strong> 、<strong><em>方法法区</em></strong> 和 <strong><em>栈</em></strong>。<br>&emsp;&emsp;<strong><em>堆内存</em></strong> 是JVM中最大的一块由 <strong>年轻代</strong>和 <strong>老年代</strong> 组成，而年轻代内存又被分为三部分， <strong>Eden空间</strong> 、<strong>From Survivo空间</strong> 、<strong>To Survivor空间</strong> ，默认情况下年轻代按照$8:1:1$的比例来分配；<font color="#FF3030">方法区存储类信息、常量、静态变量等数据，是线程共享的区域</font> ，为与<strong>Java堆</strong>区分，方法区还有一个别名NonHeap(非堆)；栈又分为 <strong>Java虚拟机栈</strong> 和 <strong>本地方法栈</strong> 主要用于方法的执行。<br>&emsp;&emsp;<font color="#FF0000">JAVA的JVM的内存可分为3个区</font>： <strong>堆(Heap)</strong>、 <strong>栈(Stack)</strong>  、 <strong>方法区(Method Area)</strong> 。实际IDEA开发Tomcat启动项配置示例：  </p><blockquote><font face="微软雅黑" color="#9900ff" size="2">-Xms1024m -Xmx1024m  -XX:PermSize=512M -XX:MaxPermSize=1024m  -Dfile.encoding=utf-8 </font>   </blockquote><a id="more"></a><hr><h3 id="Java堆-Java-Heap"><a href="#Java堆-Java-Heap" class="headerlink" title="Java堆(Java Heap)"></a>Java堆(Java Heap)</h3><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>Java堆可通过参数 <font color="#EE7942">-Xms</font> 和  <font color="#EE7942">-Xmx</font>设置；</p><h4 id="存储内容"><a href="#存储内容" class="headerlink" title="存储内容"></a>存储内容</h4><p>Java堆是存放对象的实例，几乎所有的<font color="#EE6A50">对象实例</font>和<font color="#EE6A50">数组</font>都存储于此区域，是被所有线程共享，是JVM虚拟机管理的内存中最大的一块，在虚拟机启动时创建；</p><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>为了便于更好的回收和分配内存，堆可细分为：<strong>新生代</strong>和<strong>老年代</strong>，<strong>新生代</strong> 在细致一些就是<font color="#EE3B3B">Eden空间、From Survivor空间、To Survivor区</font>。</p><ol><li>新生代：包括Eden区、From Survivor区、To Survivor区，系统默认大小 $Eden:Survivor= 8:1$</li><li>老年代：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中。因此可认为老年代中存放的都是一些生命周期较长的对象</li></ol><p>Survivor空间等Java堆可以处理在物理内存不连续的空间，只要逻辑上是连续即可。</p><hr><h3 id="Java虚拟机栈-Stack"><a href="#Java虚拟机栈-Stack" class="headerlink" title="Java虚拟机栈(Stack)"></a>Java虚拟机栈(Stack)</h3><h4 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h4><p>可通过参数 栈帧是方法运行期的基础数据结构栈容量可由-Xss设置；</p><h4 id="存储内容-1"><a href="#存储内容-1" class="headerlink" title="存储内容"></a>存储内容</h4><p>Java虚拟机栈是线程私有的，它的生命周期与线程相同</p><ol><li>每个方法被调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中从入栈到出栈的过程</li><li><p>虚拟机栈是执行Java方法的内存模型(也就是字节码)服务：**每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p><ol><li><font color="#FF0000">局部变量表</font>：32位变量槽，存放了编译期可知的 <strong>各种基本数据类型</strong>、<strong>对象引用</strong>、<strong>returnAddress类型</strong></li><li><font color="#FF0000">操作数栈</font>：基于栈的执行引擎，虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。</li><li><font color="#FF0000">动态链接</font>：<strong>每个栈帧都包含一个指向运行时常量池(方法区的一部分)中该栈帧所属方法的引用</strong>。持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为<strong>静态解析</strong>。另一部分将在每次的运行期间转化为直接应用，这部分称为<strong>动态链接</strong></li><li><font color="#FF0000">方法出口</font>：返回方法被调用的位置，恢复上层方法的局部变量和操作数栈，如果无返回值，则把它压入调用者的操作数栈。</li></ol></li><li><p><strong>局部变量表所需的内存空间在编译期间完成分配</strong>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的。</p></li><li><strong>在方法运行期间不会改变局部变量表的大小。主要存放了编译之后可知的各种基本数据类型、对象引用。</strong><font color="#33ccff">（<a href="http://www.runoob.com/java/java-basic-datatypes.html" target="_blank" rel="noopener">reference类型、returnAddress类型</a>）</font></li></ol><hr><h3 id="本地方法栈-Local-Method-Stack"><a href="#本地方法栈-Local-Method-Stack" class="headerlink" title="本地方法栈(Local Method Stack)"></a>本地方法栈(Local Method Stack)</h3><h4 id="参数设置-2"><a href="#参数设置-2" class="headerlink" title="参数设置"></a>参数设置</h4><p>可通过参数 栈容量可由-Xss设置。</p><h4 id="存储内容-2"><a href="#存储内容-2" class="headerlink" title="存储内容"></a>存储内容</h4><ol><li>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务。</li><li>本地方法栈则是为虚拟机使用到的Native方法服务。有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</li></ol><hr><h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h3><h4 id="参数设置-3"><a href="#参数设置-3" class="headerlink" title="参数设置"></a>参数设置</h4><p>可通过参数-XX:MaxPermSize设置</p><h4 id="存储内容-3"><a href="#存储内容-3" class="headerlink" title="存储内容"></a>存储内容</h4><ol><li><strong>线程共享内存区域，用于储存已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码，方法区也称持久代（Permanent Generation）</strong>。</li><li>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做<font color="#DC143C">Non-Heap（非堆）</font>，目的应该是与Java堆区分开来。</li><li>如何实现方法区，属于虚拟机的实现细节，不受虚拟机规范的约束。</li><li>方法区主要存放java类定义信息，与垃圾回收关系不大，方法区可以选择不实现垃圾回收，<font color="#EE2C2C">但不是没有垃圾回收</font>。</li><li><strong>方法区域的内存回收目标主要针对常量池的回收和对类型的卸载。</strong></li><li><strong><font color="#EE2C2C">运行时常量池</font>，也是方法区的一部分，虚拟机加载Class后把常量池中的数据放入运行时常量池</strong>。</li></ol><hr><h3 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池(Runtime Constant Pool)"></a>运行时常量池(Runtime Constant Pool)</h3><h4 id="参数设置-4"><a href="#参数设置-4" class="headerlink" title="参数设置"></a>参数设置</h4><p>可通过参数-XX:PermSize和-XX:MaxPermSize设置</p><h4 id="存储内容-4"><a href="#存储内容-4" class="headerlink" title="存储内容"></a>存储内容</h4><ol><li><font color="#EE4000">常量池(Constant Pool)</font>：<strong>常量池数据编辑之后被确定，是Class文件中的一部分。存储了类、方法、接口等中的常量，也包括字符串常量。</strong></li><li><font color="#EE4000">字符串池/字符串常量池(String  Pool/ String Constant Pool)</font>：是常量池中的一部分，存储编译期类中产生的<font color="#EE0000">字符串类型数据。</font></li><li><font color="#EE4000">运行时常量池(Runtime Constant Pool)</font>：**方法区的一部分，所有线程共享。虚拟机加载Class后把常量池中的数据放入到运行时常量池**。<font color="#EE3B3B">常量池</font>：可以理解为Class文件中的资源仓库，它是Class文件结构中与其他项目资源关联最多的数据类型。 1. 常量池中主要存放两大类常量：<font color="#EE4000">字面量</font>(Literal)和<font color="#EE4000">符号引用</font>(Symbolic Reference)。 2. **字面量**：文本字符串、声明为final的常量值等。 3. **符号引用**：<font color="#EE4000">类和接口的完全限定名</font>(Fully Qualified Name)、<font color="#EE4000">字段的名称</font>和<font color="#EE4000">描述符</font>(Descriptor)、<font color="#EE4000">方法的名称</font>和<font color="#EE4000">描述符号</font></li></ol><hr><h3 id="直接内存-Direct-Memory"><a href="#直接内存-Direct-Memory" class="headerlink" title="直接内存(Direct Memory)"></a>直接内存(Direct Memory)</h3><h4 id="参数设置-5"><a href="#参数设置-5" class="headerlink" title="参数设置"></a>参数设置</h4><p>可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值（-Xmx指定）一样。</p><h4 id="存储内容-5"><a href="#存储内容-5" class="headerlink" title="存储内容"></a>存储内容</h4><p><strong>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</strong></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5aae4e8f6fb9a028e52d9e8c" target="_blank" rel="noopener">50个多线程面试题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存结构&quot;&gt;&lt;a href=&quot;#JVM内存结构&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构&quot;&gt;&lt;/a&gt;JVM内存结构&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;JVM内存结构主要有三大块：&lt;strong&gt;&lt;em&gt;堆内存&lt;/em&gt;&lt;/strong&gt; 、&lt;strong&gt;&lt;em&gt;方法法区&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;栈&lt;/em&gt;&lt;/strong&gt;。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;em&gt;堆内存&lt;/em&gt;&lt;/strong&gt; 是JVM中最大的一块由 &lt;strong&gt;年轻代&lt;/strong&gt;和 &lt;strong&gt;老年代&lt;/strong&gt; 组成，而年轻代内存又被分为三部分， &lt;strong&gt;Eden空间&lt;/strong&gt; 、&lt;strong&gt;From Survivo空间&lt;/strong&gt; 、&lt;strong&gt;To Survivor空间&lt;/strong&gt; ，默认情况下年轻代按照$8:1:1$的比例来分配；&lt;font color=&quot;#FF3030&quot;&gt;方法区存储类信息、常量、静态变量等数据，是线程共享的区域&lt;/font&gt; ，为与&lt;strong&gt;Java堆&lt;/strong&gt;区分，方法区还有一个别名NonHeap(非堆)；栈又分为 &lt;strong&gt;Java虚拟机栈&lt;/strong&gt; 和 &lt;strong&gt;本地方法栈&lt;/strong&gt; 主要用于方法的执行。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;font color=&quot;#FF0000&quot;&gt;JAVA的JVM的内存可分为3个区&lt;/font&gt;： &lt;strong&gt;堆(Heap)&lt;/strong&gt;、 &lt;strong&gt;栈(Stack)&lt;/strong&gt;  、 &lt;strong&gt;方法区(Method Area)&lt;/strong&gt; 。实际IDEA开发Tomcat启动项配置示例：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;font face=&quot;微软雅黑&quot; color=&quot;#9900ff&quot; size=&quot;2&quot;&gt;-Xms1024m -Xmx1024m  -XX:PermSize=512M -XX:MaxPermSize=1024m  -Dfile.encoding=utf-8 &lt;/font&gt;   



&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(3)</title>
    <link href="http://edgeowner.com/2016/04/26/JVM3/"/>
    <id>http://edgeowner.com/2016/04/26/JVM3/</id>
    <published>2016-04-26T10:00:00.000Z</published>
    <updated>2016-04-27T04:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JVM具体参数和内存区域映射图例"><a href="#JVM具体参数和内存区域映射图例" class="headerlink" title="JVM具体参数和内存区域映射图例"></a>JVM具体参数和内存区域映射图例</h4><p> &emsp;&emsp;此文主要用图例方式描绘了JVM的结构，介绍了JVM内存结构对应的参数名。</p><ul><li>在具体实现上，JVM将需要进行垃圾回收的区域分为3类：新生代（Young Generation）、老年代(Old Generation)、永久代(Permanent Generation)。其中新生代又分为eden和survival（S0、S1），具体结构如下图所示：</li><li><img src="http://p5vswdxl9.bkt.clouddn.com/jvm_and_params_map.png" alt="图示1.0"><a id="more"></a></li><li>简单讲，新生代的eden、新生代的survival、老生代里的对象存活时间依次变长。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>参数名称</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td style="text-align:left">-Xmx</td><td>初始堆大小</td></tr><tr><td style="text-align:left">-Xms</td><td>最大堆大小</td></tr><tr><td style="text-align:left">-Xss</td><td>每个线程的堆栈大小</td></tr><tr><td style="text-align:left">-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td></tr><tr><td style="text-align:left">-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td></tr><tr><td style="text-align:left">-XX:PermSize</td><td>设置持久代(perm gen)初始值</td></tr><tr><td style="text-align:left">-XX:MaxPermSize</td><td>设置持久代最大值</td></tr><tr><td style="text-align:left">-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td></tr><tr><td style="text-align:left">-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td></tr></tbody></table></div><hr><h4 id="JVM内存结构图例"><a href="#JVM内存结构图例" class="headerlink" title="JVM内存结构图例"></a>JVM内存结构图例</h4><p><img src="http://p5vswdxl9.bkt.clouddn.com/JVM_Flow.jpg" alt=""><br>   &emsp;&emsp;方法区和堆是所有<strong>线程共享的内存区域</strong>；而java栈、本地方法栈和程序计数器是运行是<strong>线程私有的内存区域</strong>。</p><ul><li><p>Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p></li><li><p>方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></li><li><p>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p></li><li><p>本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p></li><li><p>ClassLoader是负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p></li><li><p>Native Interface是负责调用本地接口的。他的作用是调用不同语言的接口给JAVA用，他会在Native Method Stack中记录对应的本地方法，然后调用该方法时就通过Execution Engine加载对应的本地lib。原本多于用一些专业领域，如JAVA驱动，地图制作引擎等，现在关于这种本地方法接口的调用已经被类似于Socket通信，WebService等方式取代。</p></li><li><p>Execution Engine是执行引擎，也叫Interpreter。Class文件被加载后，会把指令和数据信息放入内存中，Execution Engine则负责把这些命令解释给操作系统。</p></li><li><p>Runtime Data Area则是存放数据的，分为五部分：Stack，Heap，Method Area，PC Register，Native Method Stack。几乎所有的关于java内存方面的问题，都是集中在这块。下图是javapapers.com上关于Run-time Data Areas的描述：<img src="http://p5vswdxl9.bkt.clouddn.com/JVM_2.jpg" alt=""></p></li></ul><hr><h4 id="相关技术参考"><a href="#相关技术参考" class="headerlink" title="相关技术参考"></a>相关技术参考</h4><ol><li><a href="https://www.jianshu.com/p/be6f529160b6" target="_blank" rel="noopener">JVM原理分析</a></li><li><a href="https://mp.weixin.qq.com/s/ebg0bT_xBahGV7OAKorBAw" target="_blank" rel="noopener">JVM知识点总览</a></li><li><a href="https://juejin.im/post/5a1cc3596fb9a04506715aad" target="_blank" rel="noopener">JVM系列之GC</a></li><li><a href="https://juejin.im/post/59ad4cd56fb9a02477075780#heading-5" target="_blank" rel="noopener">重读 JVM</a></li><li><a href="https://mijack.github.io/2018/03/18/Garbage-Collection/" target="_blank" rel="noopener">JVM 的内存模型</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JVM具体参数和内存区域映射图例&quot;&gt;&lt;a href=&quot;#JVM具体参数和内存区域映射图例&quot; class=&quot;headerlink&quot; title=&quot;JVM具体参数和内存区域映射图例&quot;&gt;&lt;/a&gt;JVM具体参数和内存区域映射图例&lt;/h4&gt;&lt;p&gt; &amp;emsp;&amp;emsp;此文主要用图例方式描绘了JVM的结构，介绍了JVM内存结构对应的参数名。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在具体实现上，JVM将需要进行垃圾回收的区域分为3类：新生代（Young Generation）、老年代(Old Generation)、永久代(Permanent Generation)。其中新生代又分为eden和survival（S0、S1），具体结构如下图所示：&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://p5vswdxl9.bkt.clouddn.com/jvm_and_params_map.png&quot; alt=&quot;图示1.0&quot;&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(2)</title>
    <link href="http://edgeowner.com/2016/04/24/jvm2/"/>
    <id>http://edgeowner.com/2016/04/24/jvm2/</id>
    <published>2016-04-24T12:00:00.000Z</published>
    <updated>2016-04-24T12:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存结构（运行时数据区）"><a href="#JVM内存结构（运行时数据区）" class="headerlink" title="JVM内存结构（运行时数据区）"></a>JVM内存结构（运行时数据区）</h3><p>该文承接<strong><a href="http://edgeowner.com/2016/04/19/jvm/">JVM内存结构简介(1)</a></strong>博文主要介绍所有<code>线程共享的区域</code>(<strong><em>方法区 </em></strong>和<strong><em>堆</em></strong>))，本文简单介绍剩余JVM的是三个区域：<code>Java栈(Java Stack)</code>、<code>本地方法栈(Native Method Stack)</code>、<code>程序计数器(Program Counter Register)</code>。</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h4 id="三、Java虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#三、Java虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="三、Java虚拟机栈(Java Virtual Machine Stacks)"></a>三、Java虚拟机栈(Java Virtual Machine Stacks)</h4><ol><li><strong>作用</strong>：描述的就是Java方法执行的内存模型。每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于存储<code>局部变量表</code>、<code>操作栈</code>、<code>动态链接</code>、<code>方法出口</code>等信息。每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈道出栈的过程。一个方法的执行过程就等同于栈帧进栈出栈的过程。</li><li><strong>特点</strong>：线程私有的，生命周期和线程相同。栈是一个后进先出(<strong>LIFO</strong>)的数据结构，每次方法调用时，一个新的栈帧创建并被压栈到栈顶， 当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。除了栈帧的压栈和出栈，栈不能被直接操作。 在JVM中，若线程请求栈的深度 超过了虚拟机允许的最大深度 ，则会抛出StackOverflowError异常；当栈进行动态扩展，但 无法申请到相应内存空间（此时，线程请求的栈深度未超过虚拟机允许的最大深度）时，则会抛出OutOfMemoryError异常。</li><li><code>局部变量表</code>：存放了编译期间可以知道大小的各种类型变量，它所需要的内存空间大小在编译期间就已经分配，当一个方法被调用时，栈帧进入虚拟机栈，在运行期间，局部变量表大小是不会变化的。</li><li><code>栈帧(Frame)</code>：<strong><em>栈帧只存储指向堆中对象或数组的引用 </em></strong>，包含<code>局部变量数组</code>、<code>返回值</code>、<code>操作数栈</code>、<code>类当前方法运行时常量池引用</code>：  <blockquote><p><code>局部变量数组</code>：包含了方法执行过程中所有变量，包括this引用、所有方法参数、其他局部变量。对于类方法（也就是静态方法），方法参数从下标 0 开始，对于对象方法，位置0保留为 this。（boolean、byte、char、long、short、int、float、double、reference、returnAddress均为局部变量，除了 long 和 double 类型以外，所有的变量类型都占用局部变量数组的一个位置。long 和 double 需要占用局部变量数组两个连续的位置，因为它们是 64 位双精度，其它类型都是 32 位单精度。）<br><code>操作数栈</code>：在执行字节码指令过程中被用到，这种方式类似于原生<strong>CPU寄存器</strong>。大部分JVM字节码把时间花费在操作数栈的操作上：<strong><em>入栈 </em></strong>、<strong><em>出栈 </em></strong> 、<strong><em>复制 </em></strong> 、<strong><em>交换 </em></strong>、<strong><em>产生消费变量 </em></strong>的操作。因此，局部变量数组和操作数栈之间的交换变量指令操作通过字节码频繁执行。比如，一个简单的变量初始化语句将产生两条跟操作数栈交互的字节码。<br>关于局部变量数组、操作数栈和运行时常量池之间交互的详细信息，可以在类文件结构部分找到。</p></blockquote></li></ol><hr><h4 id="四、本地方法栈-Native-Method-Stack"><a href="#四、本地方法栈-Native-Method-Stack" class="headerlink" title="四、本地方法栈(Native Method Stack)"></a>四、本地方法栈(Native Method Stack)</h4><ol><li><strong>作用</strong>：Java虚拟机在实现时，可以根据自身需求，确定是否实现本地方法栈。在实现上，JVM可能会使用到传统的栈（通常称之为“C Stacks”）来支持 native 方法（指使用 Java 以外的其他语言编写的方法）的执行，这个栈就是本地方法栈。当JVM支持本地方法栈时，这个栈会在线程创建时按照线程分配。 在JVM中，本地方法栈可能发生的异常情况也分为Stack OverflowError和OutOfMemoryError异常，出错原因和虚拟机栈相似，此处不再赘述。</li><li><strong>特点</strong>：Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。本地方法栈则是为虚拟机使用到的Native方法服务.</li></ol><hr><h4 id="五、程序计数器-Program-Counter-Register"><a href="#五、程序计数器-Program-Counter-Register" class="headerlink" title="五、程序计数器(Program Counter Register)"></a>五、程序计数器(Program Counter Register)</h4><ul><li>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li><strong><em>在任意时刻，一个Java虚拟机线程只会执行一个方法，而 PC Java 虚拟机允许多条线程同时执行。因此，每一条 Java虚拟机线程都有自己的 PC 寄存器 ，他们是相互独立的。每一条 Java虚拟机线程都有自己的PC 寄存器，他们是相互独立的。 </em></strong></li><li>我们称正在被线程执行的方法称为该线程的当前方法（Current Method）。如果这个方法不是 native 的，那 PC 寄存器就保存 Java 虚拟机正在执行的字节码指令的地址，如果该方法是 native 的，那 PC 寄存器的值是 undefined。</li><li>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</li><li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;a href=&quot;#JVM内存结构（运行时数据区）&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;/a&gt;JVM内存结构（运行时数据区）&lt;/h3&gt;&lt;p&gt;该文承接&lt;strong&gt;&lt;a href=&quot;http://edgeowner.com/2016/04/19/jvm/&quot;&gt;JVM内存结构简介(1)&lt;/a&gt;&lt;/strong&gt;博文主要介绍所有&lt;code&gt;线程共享的区域&lt;/code&gt;(&lt;strong&gt;&lt;em&gt;方法区 &lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;堆&lt;/em&gt;&lt;/strong&gt;))，本文简单介绍剩余JVM的是三个区域：&lt;code&gt;Java栈(Java Stack)&lt;/code&gt;、&lt;code&gt;本地方法栈(Native Method Stack)&lt;/code&gt;、&lt;code&gt;程序计数器(Program Counter Register)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>多线程相关知识点</title>
    <link href="http://edgeowner.com/2016/04/23/thread-sample-introduce/"/>
    <id>http://edgeowner.com/2016/04/23/thread-sample-introduce/</id>
    <published>2016-04-23T12:20:43.000Z</published>
    <updated>2016-04-23T13:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引入线程技术背景"><a href="#引入线程技术背景" class="headerlink" title="引入线程技术背景"></a>引入线程技术背景</h3><ol><li>一个应用程序中同时存在多个任务，其中部分活动会随时间的推移而阻塞，而另外一部分则不会。例如：一个文字处理软件，前台部分需要从终端设备获得输入或者将处理完的部分输出，而后台线程则可以实现对文字的处理。故对于CPU密集型进程，该用多线程其性能不一定能得到很大提高，但对于IO密集型进程，其性能可得到很大提高。</li><li><font color="#FF4500"> 线程比进程更轻量级，创建和撤销的代价小，在许多系统中国呢，创建一个线程比一个进程要快10～100倍不等</font>。</li><li>在多核CPU中，真正的并行有了可能。即在多线程设计中一部分可用来处理前台任务，一部分可用来处理后台任务，实现真正意义上的并行。</li><li>线程间的切换代价要比进程切换的代价小。</li></ol><a id="more"></a><hr><h3 id="引入线程技术背景-1"><a href="#引入线程技术背景-1" class="headerlink" title="引入线程技术背景"></a>引入线程技术背景</h3><ol><li>某个操作可能会陷入长时间等待，等待的线程会进入睡眠状态，无法继续进行。多线程执行可以有效利用等待时间。如等待网络响应可能需要几秒时间。</li><li>某个操作(常常是计算)会消耗大量的时间，如果只有一个线程，程序和用户之间交互会中断。多线程可以让一个线程负责交付，另一个线程负责计算。</li><li>多CPU或者多核计算机，本身具备同时执行多个线程的能力，故单线程无法完全发挥计算机的计算能力。</li><li>相对于多进程应用，多线层在数据共享方面效率要高得多。</li><li>程序逻辑本身就要求并发操作。</li></ol><hr><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>&emsp;&emsp;进程是操作系统的管理单位，线程则是进程的管理单位。一个线程至少包含一个执行线程。不管是在多线程还是单线程，每个线程都一个程序计数器（记录要执行的下一条指令），一组寄存器（保存当前线程的工作变量），堆栈（记录执行理事，其中每一帧保存了一个已经调用但为返回的过程）。虽然线程<strong><em>寄生 </em></strong>在进程中，但与它的进程是不同的概念，并且可以分别处理：<font color="#FF4500">进程是系统分配资源的基本单位，线程是调度CPU的基本单位</font>。</p><div class="table-container"><table><thead><tr><th>每个进程中的内容</th><th>每个线程的内容</th></tr></thead><tbody><tr><td>地址空间</td><td>程序计数器</td></tr><tr><td>全局变量</td><td>寄存器</td></tr><tr><td>打开文件</td><td>堆栈</td></tr><tr><td>子进程</td><td>状态</td></tr><tr><td>即将发生的报警</td><td></td></tr><tr><td>信号与信号处理程序</td><td></td></tr><tr><td>账户信号</td><td></td></tr><tr><td>同步、互斥信号量</td></tr></tbody></table></div><hr><h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><p>&emsp;&emsp;进程执行由CPU进行周期和I/O等待周期组成。进程在这两个状态之间切换（CPU burst ～ IO burst）<br>进程执行从CPU区间（CPU burst）开始，在这之后是IO区间（IO burst）。接着另外一个CPU区间，然后是另外一个IO区间，如此进行下去，最后CPU区间通过系统请求中止执行。<br>经过大量CPU区间长度的测试。发现具有大量短CPU区间和少量长CPU区间。IO约束程序通常具有很多短CPU区间。CPU约束成层序可能有少量的长CPU区间。这种分布有助于选择合适的CPU调度算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引入线程技术背景&quot;&gt;&lt;a href=&quot;#引入线程技术背景&quot; class=&quot;headerlink&quot; title=&quot;引入线程技术背景&quot;&gt;&lt;/a&gt;引入线程技术背景&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;一个应用程序中同时存在多个任务，其中部分活动会随时间的推移而阻塞，而另外一部分则不会。例如：一个文字处理软件，前台部分需要从终端设备获得输入或者将处理完的部分输出，而后台线程则可以实现对文字的处理。故对于CPU密集型进程，该用多线程其性能不一定能得到很大提高，但对于IO密集型进程，其性能可得到很大提高。&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#FF4500&quot;&gt; 线程比进程更轻量级，创建和撤销的代价小，在许多系统中国呢，创建一个线程比一个进程要快10～100倍不等&lt;/font&gt;。&lt;/li&gt;
&lt;li&gt;在多核CPU中，真正的并行有了可能。即在多线程设计中一部分可用来处理前台任务，一部分可用来处理后台任务，实现真正意义上的并行。&lt;/li&gt;
&lt;li&gt;线程间的切换代价要比进程切换的代价小。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java多线程" scheme="http://edgeowner.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://edgeowner.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(1)</title>
    <link href="http://edgeowner.com/2016/04/23/jvm/"/>
    <id>http://edgeowner.com/2016/04/23/jvm/</id>
    <published>2016-04-23T10:35:25.000Z</published>
    <updated>2016-04-23T12:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存结构（运行时数据区）"><a href="#JVM内存结构（运行时数据区）" class="headerlink" title="JVM内存结构（运行时数据区）"></a>JVM内存结构（运行时数据区）</h3><p>JVM内存结构指得是：运行时数据区（Runtime Data Area），由 <strong><em>方法区(Method Area) </em></strong>、<strong><em>堆(Heap) </em></strong>、<strong><em>Java栈(Java Stack) </em></strong>、<strong><em>本地方法栈(Native Method Stack)</em></strong>、<strong><em>程序计数器(Program Counter Register)</em></strong>。<br><img src="http://p5vswdxl9.bkt.clouddn.com/JVMRuntime" alt=""></p><a id="more"></a><hr><h4 id="一、方法区-Method-Area"><a href="#一、方法区-Method-Area" class="headerlink" title="一、方法区(Method Area)"></a>一、方法区(Method Area)</h4><ol><li><strong>作用</strong>： 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。此区域内存回收目标主要针对常量池回收和对类型的卸载回收。 </li><li><strong>特点</strong>：线程共享 。</li><li><strong>永久代的疑问(PerGen)</strong>：该内存区域一般被称为”_<strong>永久代(Permanent Generation)</strong>_ “，二者并不等价，设计之初就把GC分代收集扩展至方法区，或者说使用永久代实现方法区而已。</li><li><strong>运行时常量池</strong>：方法区的一部分，存放<strong><em>编译期</em></strong>生成的<strong>各种字面量</strong>(“zdy”,”123”等)和 <strong>符号引用</strong> 。编译器和运行期的intern()都可以将常量放入池中。受方法区限制，常量池无法申请到内存时会抛出OutOfMemoryError异常。运行时常量池具有动态性，并非只有Class文件中的内容才能进入运行时常量池，<strong><em>运行期间</em></strong>也能将新的常量放入池中。如String.intern（）方法。</li><li><strong>方法区储存类的信息</strong>： <ol><li><code>Classloader引用</code>；</li><li><code>运行时常量池</code>：数值型常量、字段引用、方法引用、属   性；  </li><li><code>字段数据</code>：针对每个字段的信息、字段名、类型、修饰符、属性；</li><li><code>方法数据</code>：每个方法、方法名、返回值类型、参数类型、修饰符、属性；</li><li><code>方法代码</code>：每个方法、字节码、操作数栈大小、局部变量大小、局部变量表、异常表、每个异常处理器、开始点、结束点、异常处理代码的程序计数器偏移量、被捕获异常类对应的常量池下标；</li></ol></li></ol><ul><li><strong><em> 字面量(literal) </em></strong>：由字母，数字等构成的字符串或者数值，用于表达源代码中一个固定值的表示法(notation)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。</li><li><strong><em> 符号引用 </em></strong>：简单地说就是，符号引用存在class文件中的常量池，包括类和接口的全限定名、字段的名称和描述符以及方法的名称和描述符。jvm加载class的时候就可以凭着这三者进行动态连接，得到具体的内存地址。占用的数据结构在常量池项目类型有，例如类或接口的符号引用结构为u1的tag和u2的name_index。</li></ul><hr><h4 id="二、堆-Heap"><a href="#二、堆-Heap" class="headerlink" title="二、堆(Heap)"></a>二、堆(Heap)</h4><ol><li><strong> 作用 </strong>：被所有线程运行时共享的内存区域，JVM启动之后，存放对象实例和数组，内部会划出多个线程私有的分配缓冲区(Thread Location Allocation Buffer ,<strong>TLAB</strong>)。该存储区域物理上可以是不连续空间，但是逻辑上一定要连续。</li><li><strong> 特点 </strong>：是GC管理的主要区域，由于GC（垃圾收集器）是采用分代收集算法,根据对象存活率，堆还可以分为<strong>新生代</strong>、<strong>老年代</strong>、<strong>永久代</strong>。</li><li><p><strong> 分类 </strong>：</p><blockquote><p>_<strong>新生代(Young Generation)</strong>_ ：方法中去new一个对象，那这方法调用完毕后，对象就会被回收，这就是一个典型的新生代对象。 每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后清理Eden和刚才用过的Survivor空间。<strong><em> HotSpot虚拟机默认Eden和Survivor的大小比例是8:1 </em></strong>，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。 98%的对象可回收只是一般场景下的数据，没办法保证每次回收都只有不多于10%的对象存活，当Survivor不够用时，需要依赖于老年代进行分配担保，所以<strong><em> 大对象 </em></strong>直接进入老年代。同时长期存活的对象进入老年代（虚拟机给每个对象定义一个年龄计数器）。<br><code>年轻代内存又被分成三部分</code>：  </p><ol><li><code>Eden空间</code>：对象优先分配在Eden区，若Eden区无足够的空间，虚拟机执行一次Minor GC。对象被创建时首先放到这个区域，进行垃圾回收后，不能被回收的对象被放到空的Survivor区域。</li><li><code>Survivor Space幸存者区</code>：用于保存在Eden Space内存区域中经过垃圾回收后没有被回收的对象。Survivor有两类，分别为<strong><em>To Suvivor </em></strong> 和 <strong><em>From Suvivor</em></strong>两个区域，这两个区域空间大小是一样的执行：<br>   &emsp;&emsp;a.<code>From Survivor空间</code>：<br>   &emsp;&emsp;b.<code>To Survivor空间</code> ：      </li><li><code>执行回收的内存运行</code>： 执行垃圾回收时Eden区域不能被回收的对象被放入到空的Suvivor(也就是<strong>To Survivor</strong>，同时Eden区域的内存会在垃圾回收的过程中全部释放)，另一个Survivor(即From Survivor)里不能被回收的对象也会被放入到Survivor(即To Survivor)，然后To Survivor和 From Survivor的标记会互换，始终保证一个Survivor是空的。 </li></ol><p>_<strong>老年代(Old Generation)</strong>_ ：<strong> 老年代空间大小&emsp;=&emsp;堆空间大小&emsp;—&emsp;年轻代大空间大小 </strong>   </p></blockquote></li><li><p><strong> 年轻代的垃圾回收 </strong>：<strong><em>Eden Space(伊甸园) </em></strong>和<strong><em>Suvivor Space </em></strong>都属于新生代，新生代中执行垃圾回收被称为Minor GC(由于是对新生代进行垃圾回收，所以被称为Young GC)，每次Young GC 后留下来的对象age +1。</p><blockquote><p>_<strong> Eden:From:TO =8:1:1</strong>_<br> 由于新生代中90%的对象都是”朝生夕死”，采用复制算法是比较合理的，首先只移动了存活下来的对象(比较少数),其次内存在移动到To区域后是有顺序的，不存在内存碎片。值得一提的是，假如在一次Minor GC时,<code>Eden中存活的对象</code>+<code>From中存活的对象</code>&gt;<code>To的剩余空间</code>，则会通过担保机制将对象直接转移到Old Gen ,如果Old Gen的内存空间也不够，则进行一次Full GC .当<strong><em> 对象的年龄到达15岁时会转移到Old Gen(可通过参数配置，一般不建议更改) </em></strong></p></blockquote></li><li><p><strong> 使用方式 </strong>：Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。<strong><em> 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 </em></strong></p></li><li><code>对象分配规则</code>：<br> <code>1.对象优先分配在Eden区</code>：若Eden区没有足够的空间时，虚拟机执行一次Minor GC；<br> <code>2.大对象(大对象是指需要大量连续内存空间的对象)直接进入老年代</code>：这样做目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝(新生代采用 <strong><em>复制算法 </em></strong> 收集内存)；<br> <code>3.长期存活的对象进入老年代</code>：虚拟机为每个对象定义一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象年龄加 1，直到达到阀值，对象进入老年区；<br> <code>4.动态判断对象的年龄</code>：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代；<br> <code>5.空间分配担保</code>：每次每次进行Minor GC时，JVM会计算Survivor区移至<strong>老年区的对象</strong>的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC，如果false则进行Full GC；    </li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;a href=&quot;#JVM内存结构（运行时数据区）&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;/a&gt;JVM内存结构（运行时数据区）&lt;/h3&gt;&lt;p&gt;JVM内存结构指得是：运行时数据区（Runtime Data Area），由 &lt;strong&gt;&lt;em&gt;方法区(Method Area) &lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;堆(Heap) &lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;Java栈(Java Stack) &lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;本地方法栈(Native Method Stack)&lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;程序计数器(Program Counter Register)&lt;/em&gt;&lt;/strong&gt;。&lt;br&gt;&lt;img src=&quot;http://p5vswdxl9.bkt.clouddn.com/JVMRuntime&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>线程池介绍</title>
    <link href="http://edgeowner.com/2016/04/21/thread-pool/"/>
    <id>http://edgeowner.com/2016/04/21/thread-pool/</id>
    <published>2016-04-21T12:15:31.000Z</published>
    <updated>2016-04-21T13:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>&emsp;&emsp;很多人可能已经很熟悉操作系统中的多任务：就是同一时刻运行多个程序的能力。<br>&emsp;&emsp;多线程程序在较低层次上扩展了多任务的概念：一个程序同时执行多个任务。通常每一个任务称为一个线程，它是线程控制的简称。可以同时运行一个以上线程的程序成为多线程程序。<br>&emsp;&emsp;<font color="#EE4000">线程和进程的区别</font>：</p><ol><li>多个进程的内部数据和状态都是完全独立的，而多线程是共享一块内存空间和一组系统资源，有可能互相影响。　　</li><li>线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以线程的切换负担比进程切换的负担要小。多线程程序比多进程程序需要更少的管理费用。　　</li><li>进程是重量级的任务，需要分配给它们独立的地址空间，进程间通信是昂贵和受限的，进程间的转换也是很需要花费的。而线程是轻量级的选手，它们共享相同的地址空间并且共同分享同一个进程，线程间的通信是便宜的，线程间的转换也是低成本的。</li></ol><hr><a id="more"></a><h4 id="多线程技术背景"><a href="#多线程技术背景" class="headerlink" title="多线程技术背景"></a>多线程技术背景</h4><p>&emsp;&emsp;面向对象编程，创建和销毁对象是很浪费时间，因为创建一个对象要获取内存资源或者其它更多资源。在Java中亦是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。<br>&emsp;&emsp;为了提高服务程序的效率，尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁。如何利用已有对象来服务就是一个需要解决的关键问题，其实这就是一些”池化资源”技术产生的原因。<br>&emsp;&emsp;线程池为我们做的，就是线程创建之后为我们保留，当我们需要的时候直接拿来用，省去了重复创建销毁的过程。<br><img src="http://p5vswdxl9.bkt.clouddn.com/threadPool" alt="线程"></p><hr><h4 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h4><ul><li>重用线程中的线程，减少因对象创建、销毁所带来的性能开销；</li><li>能有效的控制线程的最大并发数，提高系统资源利用率，同时避免过多的资源竞争，避免堵塞；</li><li>能够多线程进行简单的管理，使线程的使用简单、高效；</li></ul><hr><h4 id="线程池的处理逻辑"><a href="#线程池的处理逻辑" class="headerlink" title="线程池的处理逻辑"></a>线程池的处理逻辑</h4><h5 id="线程池ThreadPoolExecutor构造函数"><a href="#线程池ThreadPoolExecutor构造函数" class="headerlink" title="线程池ThreadPoolExecutor构造函数"></a>线程池ThreadPoolExecutor构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//五个参数的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//六个参数的构造函数（1）</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//六个参数的构造函数（2） </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//七个参数的构造函数 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="构造函数参数介绍"><a href="#构造函数参数介绍" class="headerlink" title="构造函数参数介绍"></a>构造函数参数介绍</h5><ol><li><strong>corePoolSize（核心线程， 该线程池中核心线程数最大值</strong>：在创建完线程池之后，核心线程先不创建，在接到任务之后创建核心线程。并且会意一直存在于线程池中(即使这个线程什么多不做)，有任务要执行时，如果核心线程没有被占用，会优先用核心线程执行任务。数量一般情况下设置为CPU核数的二倍即可。</li><li><strong>maximumPoolSize （该线程池中线程总数最大值）</strong>：线程总数 $=$ 核心线程数 $+$ 非核心线程数。（非核心线程：简单理解，即核心线程都被占用，但还有任务要做，就创建非核心线程）</li><li><strong>keepAliveTime（非核心线程闲置超时时长）</strong>：这个参数可以理解为，任务少，但池中线程多，非核心线程不能白养着，超过这个时间不工作的就会被干掉，但是核心线程会保留。</li><li><strong>TimeUnit（keepAliveTime的单位）</strong>：<br> TimeUnit是一个枚举类型，其包括:<br> NANOSECONDS ： 1微毫秒 = 1微秒 / 1000<br> MICROSECONDS ： 1微秒 = 1毫秒 / 1000<br> MILLISECONDS ： 1毫秒 = 1秒 /1000<br> SECONDS ： 秒<br> MINUTES ： 分<br> HOURS ： 小时<br> DAYS ： 天</li><li><p><strong>BlockingQueue workQueue（线程池中的任务队列）</strong>：默认情况下，任务进来之后先分配给核心线程执行，核心线程如果都被占用，并不会立刻开启非核心线程执行任务，而是将任务插入任务队列等待执行，核心线程会从任务队列取任务来执行，任务队列可以设置最大值，一旦插入的任务足够多，达到最大值，才会创建非核心线程执行任务。常见的workQueue有四种：</p><ul><li><strong>SynchronousQueue</strong>：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大；</li><li><strong>LinkedBlockingQueue</strong>：这个队列接收到任务的时候，如果当前已经创建的核心线程数小于线程池的核心线程数上限，则新建线程(核心线程)处理任务；如果当前已经创建的核心线程数等于核心线程数上限，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize；</li><li><strong>ArrayBlockingQueue</strong>：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误，或是执行实现定义好的饱和策略</li><li><strong>DelayQueue</strong>：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务；</li></ul></li><li><p><strong>ThreadFactory threadFactory （创建线程的工厂）</strong>：可以用线程工厂给每个创建出来的线程设置名字。一般情况下无须设置该参数。</p></li><li><strong>RejectedExecutionHandler handler（饱和策略）</strong>：这是当任务队列和线程池都满了时所采取的应对策略，默认是<strong><em>AbordPolicy </em></strong>， 表示无法处理新任务，并抛出 RejectedExecutionException 异常。此外还有3种策略，它们分别如下：<ul><li><strong>CallerRunsPolicy</strong>：用调用者所在的线程来处理任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。     </li><li><strong>DiscardPolicy</strong>：不能执行的任务，并将该任务删除。</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列最近的任务，并执行当前的任务。</li><li>接下来上图，相信结合图你能大彻大悟~<img src="http://p5vswdxl9.bkt.clouddn.com/thpool" alt=""></li></ul></li></ol><hr><h4 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a>线程池使用</h4><p>java为我们提供了4种线程池FixedThreadPool、CachedThreadPool、SingleThreadExecutor、ScheduledThreadPool，几乎可以满足我们大部分的需要。</p><ul><li><p><strong><em>FixedThreadPool </em></strong>可重用固定线程数的线程池，超出的线程会在队列中等待，在Executors类中我们可以找到创建方式：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><em>CachedThreadPool </em></strong>是一个根据需要创建线程的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong><em>SingleThreadExecutor </em></strong>是使用单个线程工作的线程池。其创建源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><em> ScheduledThreadPool </em></strong>是一个能实现定时和周期性任务的线程池，它的创建源码如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="合理配置线程池的大小"><a href="#合理配置线程池的大小" class="headerlink" title="合理配置线程池的大小"></a>合理配置线程池的大小</h4><p>&emsp;&emsp;一般需要根据任务的类型来配置线程池大小：</p><ul><li>如果是CPU密集型任务（<strong><em>线程CPU时间所占比例越高，需要越少线程，即CPU密集型任务。 </em></strong> ），就需要尽量压榨CPU，参考值可以设为 NCPU+1；</li><li>如果是IO密集型任务（<strong><em>线程等待时间所占比例越高，需要越多线程，即IO密集型任务 </em></strong> ），参考值可以设置为2*NCPU；</li><li>具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整；</li><li>最佳线程数目 = ((线程等待时间+线程CPU时间)/线程CPU时间)$*$CPU数目；</li><li>比如平均每个线程CPU运行时间为0.5s，而线程等待时间（非CPU运行时间，比如IO）为1.5s，CPU核心数为8，那么根据上面这个公式估算得到：((0.5+1.5)/0.5)$*$8=32；</li><li>TODO</li></ul><p><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;很多人可能已经很熟悉操作系统中的多任务：就是同一时刻运行多个程序的能力。&lt;br&gt;&amp;emsp;&amp;emsp;多线程程序在较低层次上扩展了多任务的概念：一个程序同时执行多个任务。通常每一个任务称为一个线程，它是线程控制的简称。可以同时运行一个以上线程的程序成为多线程程序。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;font color=&quot;#EE4000&quot;&gt;线程和进程的区别&lt;/font&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个进程的内部数据和状态都是完全独立的，而多线程是共享一块内存空间和一组系统资源，有可能互相影响。　　&lt;/li&gt;
&lt;li&gt;线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以线程的切换负担比进程切换的负担要小。多线程程序比多进程程序需要更少的管理费用。　　&lt;/li&gt;
&lt;li&gt;进程是重量级的任务，需要分配给它们独立的地址空间，进程间通信是昂贵和受限的，进程间的转换也是很需要花费的。而线程是轻量级的选手，它们共享相同的地址空间并且共同分享同一个进程，线程间的通信是便宜的，线程间的转换也是低成本的。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Java多线程" scheme="http://edgeowner.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://edgeowner.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://edgeowner.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor 参数详解</title>
    <link href="http://edgeowner.com/2016/04/21/ThreadPoolExecutor/"/>
    <id>http://edgeowner.com/2016/04/21/ThreadPoolExecutor/</id>
    <published>2016-04-21T01:15:31.000Z</published>
    <updated>2016-04-21T12:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ThreadPoolExecutor类介绍"><a href="#ThreadPoolExecutor类介绍" class="headerlink" title="ThreadPoolExecutor类介绍"></a>ThreadPoolExecutor类介绍</h3><p>&emsp;&emsp; </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ThreadPoolExecutor类介绍&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor类介绍&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor类介绍&quot;&gt;&lt;/a&gt;ThreadPoolExecutor类介绍&lt;/
      
    
    </summary>
    
      <category term="Java多线程" scheme="http://edgeowner.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://edgeowner.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://edgeowner.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
</feed>
