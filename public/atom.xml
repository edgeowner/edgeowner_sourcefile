<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>edgeowner</title>
  
  <subtitle>多读书，读好书，少写bug</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://edgeowner.com/"/>
  <updated>2018-04-03T03:17:34.243Z</updated>
  <id>http://edgeowner.com/</id>
  
  <author>
    <name>ZhangSunny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo搭建指南（一）</title>
    <link href="http://edgeowner.com/2018/04/03/Hexo/"/>
    <id>http://edgeowner.com/2018/04/03/Hexo/</id>
    <published>2018-04-03T03:16:57.000Z</published>
    <updated>2018-04-03T03:17:34.243Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java序列化</title>
    <link href="http://edgeowner.com/2018/03/13/Java%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://edgeowner.com/2018/03/13/Java序列化/</id>
    <published>2018-03-13T12:06:04.000Z</published>
    <updated>2018-03-14T02:28:55.234Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java" scheme="http://edgeowner.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://edgeowner.com/tags/Java/"/>
    
      <category term="Serialize" scheme="http://edgeowner.com/tags/Serialize/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO</title>
    <link href="http://edgeowner.com/2018/03/13/Java-NIO/"/>
    <id>http://edgeowner.com/2018/03/13/Java-NIO/</id>
    <published>2018-03-13T12:05:28.000Z</published>
    <updated>2018-03-14T02:35:31.573Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java LDAP</title>
    <link href="http://edgeowner.com/2018/03/13/Java-LDAP/"/>
    <id>http://edgeowner.com/2018/03/13/Java-LDAP/</id>
    <published>2018-03-13T12:05:05.000Z</published>
    <updated>2018-03-14T02:35:23.955Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java CAS</title>
    <link href="http://edgeowner.com/2018/03/13/Java-CAS/"/>
    <id>http://edgeowner.com/2018/03/13/Java-CAS/</id>
    <published>2018-03-13T12:04:50.000Z</published>
    <updated>2018-03-19T10:37:03.986Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java面试题目集锦 (1)</title>
    <link href="http://edgeowner.com/2016/06/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E9%9B%86%E9%94%A6/"/>
    <id>http://edgeowner.com/2016/06/01/Java面试题目集锦/</id>
    <published>2016-06-01T12:21:37.000Z</published>
    <updated>2018-03-14T02:35:47.142Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java面试题目汇总" scheme="http://edgeowner.com/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    
    
      <category term="Java" scheme="http://edgeowner.com/tags/Java/"/>
    
      <category term="面试题" scheme="http://edgeowner.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(3)</title>
    <link href="http://edgeowner.com/2016/04/26/JVM3/"/>
    <id>http://edgeowner.com/2016/04/26/JVM3/</id>
    <published>2016-04-26T10:00:00.000Z</published>
    <updated>2016-04-27T04:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JVM具体参数和内存区域映射图例"><a href="#JVM具体参数和内存区域映射图例" class="headerlink" title="JVM具体参数和内存区域映射图例"></a>JVM具体参数和内存区域映射图例</h4><p> &emsp;&emsp;此文主要用图例方式描绘了JVM的结构，介绍了JVM内存结构对应的参数名。</p><ul><li>在具体实现上，JVM将需要进行垃圾回收的区域分为3类：新生代（Young Generation）、老年代(Old Generation)、永久代(Permanent Generation)。其中新生代又分为eden和survival（S0、S1），具体结构如下图所示：</li><li><img src="http://p5vswdxl9.bkt.clouddn.com/jvm_and_params_map.png" alt="图示1.0"><a id="more"></a></li><li>简单讲，新生代的eden、新生代的survival、老生代里的对象存活时间依次变长。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>参数名称</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td style="text-align:left">-Xmx</td><td>初始堆大小</td></tr><tr><td style="text-align:left">-Xms</td><td>最大堆大小</td></tr><tr><td style="text-align:left">-Xss</td><td>每个线程的堆栈大小</td></tr><tr><td style="text-align:left">-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td></tr><tr><td style="text-align:left">-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td></tr><tr><td style="text-align:left">-XX:PermSize</td><td>设置持久代(perm gen)初始值</td></tr><tr><td style="text-align:left">-XX:MaxPermSize</td><td>设置持久代最大值</td></tr><tr><td style="text-align:left">-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td></tr><tr><td style="text-align:left">-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td></tr></tbody></table></div><hr><h4 id="JVM内存结构图例"><a href="#JVM内存结构图例" class="headerlink" title="JVM内存结构图例"></a>JVM内存结构图例</h4><p><img src="http://p5vswdxl9.bkt.clouddn.com/JVM_Flow.jpg" alt=""><br>   &emsp;&emsp;方法区和堆是所有<strong>线程共享的内存区域</strong>；而java栈、本地方法栈和程序计数器是运行是<strong>线程私有的内存区域</strong>。</p><ul><li><p>Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p></li><li><p>方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></li><li><p>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p></li><li><p>本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p></li><li><p>ClassLoader是负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p></li><li><p>Native Interface是负责调用本地接口的。他的作用是调用不同语言的接口给JAVA用，他会在Native Method Stack中记录对应的本地方法，然后调用该方法时就通过Execution Engine加载对应的本地lib。原本多于用一些专业领域，如JAVA驱动，地图制作引擎等，现在关于这种本地方法接口的调用已经被类似于Socket通信，WebService等方式取代。</p></li><li><p>Execution Engine是执行引擎，也叫Interpreter。Class文件被加载后，会把指令和数据信息放入内存中，Execution Engine则负责把这些命令解释给操作系统。</p></li><li><p>Runtime Data Area则是存放数据的，分为五部分：Stack，Heap，Method Area，PC Register，Native Method Stack。几乎所有的关于java内存方面的问题，都是集中在这块。下图是javapapers.com上关于Run-time Data Areas的描述：<img src="http://p5vswdxl9.bkt.clouddn.com/JVM_2.jpg" alt=""></p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JVM具体参数和内存区域映射图例&quot;&gt;&lt;a href=&quot;#JVM具体参数和内存区域映射图例&quot; class=&quot;headerlink&quot; title=&quot;JVM具体参数和内存区域映射图例&quot;&gt;&lt;/a&gt;JVM具体参数和内存区域映射图例&lt;/h4&gt;&lt;p&gt; &amp;emsp;&amp;emsp;此文主要用图例方式描绘了JVM的结构，介绍了JVM内存结构对应的参数名。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在具体实现上，JVM将需要进行垃圾回收的区域分为3类：新生代（Young Generation）、老年代(Old Generation)、永久代(Permanent Generation)。其中新生代又分为eden和survival（S0、S1），具体结构如下图所示：&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://p5vswdxl9.bkt.clouddn.com/jvm_and_params_map.png&quot; alt=&quot;图示1.0&quot;&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(2)</title>
    <link href="http://edgeowner.com/2016/04/24/jvm2/"/>
    <id>http://edgeowner.com/2016/04/24/jvm2/</id>
    <published>2016-04-24T12:00:00.000Z</published>
    <updated>2016-04-24T12:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存结构（运行时数据区）"><a href="#JVM内存结构（运行时数据区）" class="headerlink" title="JVM内存结构（运行时数据区）"></a>JVM内存结构（运行时数据区）</h3><p>该文承接<strong><a href="http://edgeowner.com/2016/04/19/jvm/">JVM内存结构简介(1)</a></strong>博文主要介绍所有<code>线程共享的区域</code>(<strong><em>方法区 </em></strong>和<strong><em>堆</em></strong>))，本文简单介绍剩余JVM的是三个区域：<code>Java栈(Java Stack)</code>、<code>本地方法栈(Native Method Stack)</code>、<code>程序计数器(Program Counter Register)</code>。</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h4 id="三、Java虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#三、Java虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="三、Java虚拟机栈(Java Virtual Machine Stacks)"></a>三、Java虚拟机栈(Java Virtual Machine Stacks)</h4><ol><li><strong>作用</strong>：描述的就是Java方法执行的内存模型。每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于存储<code>局部变量表</code>、<code>操作栈</code>、<code>动态链接</code>、<code>方法出口</code>等信息。每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈道出栈的过程。一个方法的执行过程就等同于栈帧进栈出栈的过程。</li><li><strong>特点</strong>：线程私有的，生命周期和线程相同。栈是一个后进先出(<strong>LIFO</strong>)的数据结构，每次方法调用时，一个新的栈帧创建并被压栈到栈顶， 当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。除了栈帧的压栈和出栈，栈不能被直接操作。 在JVM中，若线程请求栈的深度 超过了虚拟机允许的最大深度 ，则会抛出StackOverflowError异常；当栈进行动态扩展，但 无法申请到相应内存空间（此时，线程请求的栈深度未超过虚拟机允许的最大深度）时，则会抛出OutOfMemoryError异常。</li><li><code>局部变量表</code>：存放了编译期间可以知道大小的各种类型变量，它所需要的内存空间大小在编译期间就已经分配，当一个方法被调用时，栈帧进入虚拟机栈，在运行期间，局部变量表大小是不会变化的。</li><li><code>栈帧(Frame)</code>：<strong><em>栈帧只存储指向堆中对象或数组的引用 </em></strong>，包含<code>局部变量数组</code>、<code>返回值</code>、<code>操作数栈</code>、<code>类当前方法运行时常量池引用</code>：  <blockquote><p><code>局部变量数组</code>：包含了方法执行过程中所有变量，包括this引用、所有方法参数、其他局部变量。对于类方法（也就是静态方法），方法参数从下标 0 开始，对于对象方法，位置0保留为 this。（boolean、byte、char、long、short、int、float、double、reference、returnAddress均为局部变量，除了 long 和 double 类型以外，所有的变量类型都占用局部变量数组的一个位置。long 和 double 需要占用局部变量数组两个连续的位置，因为它们是 64 位双精度，其它类型都是 32 位单精度。）<br><code>操作数栈</code>：在执行字节码指令过程中被用到，这种方式类似于原生<strong>CPU寄存器</strong>。大部分JVM字节码把时间花费在操作数栈的操作上：<strong><em>入栈 </em></strong>、<strong><em>出栈 </em></strong> 、<strong><em>复制 </em></strong> 、<strong><em>交换 </em></strong>、<strong><em>产生消费变量 </em></strong>的操作。因此，局部变量数组和操作数栈之间的交换变量指令操作通过字节码频繁执行。比如，一个简单的变量初始化语句将产生两条跟操作数栈交互的字节码。</p><p>关于局部变量数组、操作数栈和运行时常量池之间交互的详细信息，可以在类文件结构部分找到。</p></blockquote></li></ol><hr><h4 id="四、本地方法栈-Native-Method-Stack"><a href="#四、本地方法栈-Native-Method-Stack" class="headerlink" title="四、本地方法栈(Native Method Stack)"></a>四、本地方法栈(Native Method Stack)</h4><ol><li><strong>作用</strong>：Java虚拟机在实现时，可以根据自身需求，确定是否实现本地方法栈。在实现上，JVM可能会使用到传统的栈（通常称之为“C Stacks”）来支持 native 方法（指使用 Java 以外的其他语言编写的方法）的执行，这个栈就是本地方法栈。当JVM支持本地方法栈时，这个栈会在线程创建时按照线程分配。 在JVM中，本地方法栈可能发生的异常情况也分为Stack OverflowError和OutOfMemoryError异常，出错原因和虚拟机栈相似，此处不再赘述。</li><li><strong>特点</strong>：Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。本地方法栈则是为虚拟机使用到的Native方法服务.</li></ol><hr><h4 id="五、程序计数器-Program-Counter-Register"><a href="#五、程序计数器-Program-Counter-Register" class="headerlink" title="五、程序计数器(Program Counter Register)"></a>五、程序计数器(Program Counter Register)</h4><ul><li>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li><strong><em>在任意时刻，一个Java虚拟机线程只会执行一个方法，而 PC Java 虚拟机允许多条线程同时执行。因此，每一条 Java虚拟机线程都有自己的 PC 寄存器 ，他们是相互独立的。每一条 Java虚拟机线程都有自己的PC 寄存器，他们是相互独立的。 </em></strong></li><li>我们称正在被线程执行的方法称为该线程的当前方法（Current Method）。如果这个方法不是 native 的，那 PC 寄存器就保存 Java 虚拟机正在执行的字节码指令的地址，如果该方法是 native 的，那 PC 寄存器的值是 undefined。</li><li>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</li><li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;a href=&quot;#JVM内存结构（运行时数据区）&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;/a&gt;JVM内存结构（运行时数据区）&lt;/h3&gt;&lt;p&gt;该文承接&lt;strong&gt;&lt;a href=&quot;http://edgeowner.com/2016/04/19/jvm/&quot;&gt;JVM内存结构简介(1)&lt;/a&gt;&lt;/strong&gt;博文主要介绍所有&lt;code&gt;线程共享的区域&lt;/code&gt;(&lt;strong&gt;&lt;em&gt;方法区 &lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;堆&lt;/em&gt;&lt;/strong&gt;))，本文简单介绍剩余JVM的是三个区域：&lt;code&gt;Java栈(Java Stack)&lt;/code&gt;、&lt;code&gt;本地方法栈(Native Method Stack)&lt;/code&gt;、&lt;code&gt;程序计数器(Program Counter Register)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor 参数详解</title>
    <link href="http://edgeowner.com/2016/04/21/ThreadPoolExecutor/"/>
    <id>http://edgeowner.com/2016/04/21/ThreadPoolExecutor/</id>
    <published>2016-04-21T01:15:31.000Z</published>
    <updated>2016-04-21T12:17:23.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java Multi-thread Programming" scheme="http://edgeowner.com/categories/Java-Multi-thread-Programming/"/>
    
    
      <category term="多线程" scheme="http://edgeowner.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://edgeowner.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor 参数详解</title>
    <link href="http://edgeowner.com/2016/04/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://edgeowner.com/2016/04/20/Java多线程/</id>
    <published>2016-04-20T01:15:31.000Z</published>
    <updated>2016-04-20T12:17:23.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java Multi-thread Programming" scheme="http://edgeowner.com/categories/Java-Multi-thread-Programming/"/>
    
    
      <category term="多线程" scheme="http://edgeowner.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(1)</title>
    <link href="http://edgeowner.com/2016/04/19/jvm/"/>
    <id>http://edgeowner.com/2016/04/19/jvm/</id>
    <published>2016-04-19T10:35:25.000Z</published>
    <updated>2016-04-19T12:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存结构（运行时数据区）"><a href="#JVM内存结构（运行时数据区）" class="headerlink" title="JVM内存结构（运行时数据区）"></a>JVM内存结构（运行时数据区）</h3><p>JVM内存结构指得是：运行时数据区（Runtime Data Area），由 <strong><em>方法区(Method Area) </em></strong>、<strong><em>堆(Heap) </em></strong>、<strong><em>Java栈(Java Stack) </em></strong>、<strong><em>本地方法栈(Native Method Stack)</em></strong>、<strong><em>程序计数器(Program Counter Register)</em></strong>。<br><img src="http://p5vswdxl9.bkt.clouddn.com/JVMRuntime" alt=""></p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h4 id="一、方法区-Method-Area"><a href="#一、方法区-Method-Area" class="headerlink" title="一、方法区(Method Area)"></a>一、方法区(Method Area)</h4><ol><li><strong>作用</strong>： 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。此区域内存回收目标主要针对常量池回收和对类型的卸载回收。 </li><li><strong>特点</strong>：线程共享 。</li><li><strong>永久代的疑问(PerGen)</strong>：该内存区域一般被称为”_<strong>永久代(Permanent Generation)</strong>_ “，二者并不等价，设计之初就把GC分代收集扩展至方法区，或者说使用永久代实现方法区而已。</li><li><strong>运行时常量池</strong>：方法区的一部分，存放<strong><em>编译期</em></strong>生成的<strong>各种字面量</strong>(“zdy”,”123”等)和 <strong>符号引用</strong> 。编译器和运行期的intern()都可以将常量放入池中。受方法区限制，常量池无法申请到内存时会抛出OutOfMemoryError异常。运行时常量池具有动态性，并非只有Class文件中的内容才能进入运行时常量池，<strong><em>运行期间</em></strong>也能将新的常量放入池中。如String.intern（）方法。</li><li><strong>方法区储存类的信息</strong>： <ol><li><code>Classloader引用</code>；</li><li><code>运行时常量池</code>：数值型常量、字段引用、方法引用、属   性；  </li><li><code>字段数据</code>：针对每个字段的信息、字段名、类型、修饰符、属性；</li><li><code>方法数据</code>：每个方法、方法名、返回值类型、参数类型、修饰符、属性；</li><li><code>方法代码</code>：每个方法、字节码、操作数栈大小、局部变量大小、局部变量表、异常表、每个异常处理器、开始点、结束点、异常处理代码的程序计数器偏移量、被捕获异常类对应的常量池下标；</li></ol></li></ol><ul><li><strong><em> 字面量(literal) </em></strong>：由字母，数字等构成的字符串或者数值，用于表达源代码中一个固定值的表示法(notation)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。</li><li><strong><em> 符号引用 </em></strong>：简单地说就是，符号引用存在class文件中的常量池，包括类和接口的全限定名、字段的名称和描述符以及方法的名称和描述符。jvm加载class的时候就可以凭着这三者进行动态连接，得到具体的内存地址。占用的数据结构在常量池项目类型有，例如类或接口的符号引用结构为u1的tag和u2的name_index。</li></ul><hr><h4 id="二、堆-Heap"><a href="#二、堆-Heap" class="headerlink" title="二、堆(Heap)"></a>二、堆(Heap)</h4><ol><li><strong> 作用 </strong>：被所有线程运行时共享的内存区域，JVM启动之后，存放对象实例和数组，内部会划出多个线程私有的分配缓冲区(Thread Location Allocation Buffer ,<strong>TLAB</strong>)。该存储区域物理上可以是不连续空间，但是逻辑上一定要连续。</li><li><strong> 特点 </strong>：是GC管理的主要区域，由于GC（垃圾收集器）是采用分代收集算法,根据对象存活率，堆还可以分为<strong>新生代</strong>、<strong>老年代</strong>、<strong>永久代</strong>。</li><li><p><strong> 分类 </strong>：</p><blockquote><p>_<strong>新生代(Young Generation)</strong>_ ：方法中去new一个对象，那这方法调用完毕后，对象就会被回收，这就是一个典型的新生代对象。 每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后清理Eden和刚才用过的Survivor空间。<strong><em> HotSpot虚拟机默认Eden和Survivor的大小比例是8:1 </em></strong>，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。 98%的对象可回收只是一般场景下的数据，没办法保证每次回收都只有不多于10%的对象存活，当Survivor不够用时，需要依赖于老年代进行分配担保，所以<strong><em> 大对象 </em></strong>直接进入老年代。同时长期存活的对象进入老年代（虚拟机给每个对象定义一个年龄计数器）。<br><code>年轻代内存又被分成三部分</code>：  </p><ol><li><code>Eden空间</code>：对象优先分配在Eden区，若Eden区无足够的空间，虚拟机执行一次Minor GC。对象被创建时首先放到这个区域，进行垃圾回收后，不能被回收的对象被放到空的Survivor区域。</li><li><code>Survivor Space幸存者区</code>：用于保存在Eden Space内存区域中经过垃圾回收后没有被回收的对象。Survivor有两类，分别为<strong><em>To Suvivor </em></strong> 和 <strong><em>From Suvivor</em></strong>两个区域，这两个区域空间大小是一样的执行：<br>   &emsp;&emsp;a.<code>From Survivor空间</code>：<br>   &emsp;&emsp;b.<code>To Survivor空间</code> ：      </li><li><code>执行回收的内存运行</code>： 执行垃圾回收时Eden区域不能被回收的对象被放入到空的Suvivor(也就是<strong>To Survivor</strong>，同时Eden区域的内存会在垃圾回收的过程中全部释放)，另一个Survivor(即From Survivor)里不能被回收的对象也会被放入到Survivor(即To Survivor)，然后To Survivor和 From Survivor的标记会互换，始终保证一个Survivor是空的。 </li></ol><p>_<strong>老年代(Old Generation)</strong>_ ：<strong> 老年代空间大小&emsp;=&emsp;堆空间大小&emsp;—&emsp;年轻代大空间大小 </strong>   </p></blockquote></li><li><p><strong> 年轻代的垃圾回收 </strong>：<strong><em>Eden Space(伊甸园) </em></strong>和<strong><em>Suvivor Space </em></strong>都属于新生代，新生代中执行垃圾回收被称为Minor GC(由于是对新生代进行垃圾回收，所以被称为Young GC)，每次Young GC 后留下来的对象age +1。</p><blockquote><p>_<strong> Eden:From:TO =8:1:1</strong>_<br> 由于新生代中90%的对象都是”朝生夕死”，采用复制算法是比较合理的，首先只移动了存活下来的对象(比较少数),其次内存在移动到To区域后是有顺序的，不存在内存碎片。值得一提的是，假如在一次Minor GC时,<code>Eden中存活的对象</code>+<code>From中存活的对象</code>&gt;<code>To的剩余空间</code>，则会通过担保机制将对象直接转移到Old Gen ,如果Old Gen的内存空间也不够，则进行一次Full GC .当<strong><em> 对象的年龄到达15岁时会转移到Old Gen(可通过参数配置，一般不建议更改) </em></strong></p></blockquote></li><li><p><strong> 使用方式 </strong>：Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。<strong><em> 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 </em></strong></p></li><li><code>对象分配规则</code>：<br> <code>1.对象优先分配在Eden区</code>：若Eden区没有足够的空间时，虚拟机执行一次Minor GC；<br> <code>2.大对象(大对象是指需要大量连续内存空间的对象)直接进入老年代</code>：这样做目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝(新生代采用 <strong><em>复制算法 </em></strong> 收集内存)；<br> <code>3.长期存活的对象进入老年代</code>：虚拟机为每个对象定义一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象年龄加 1，直到达到阀值，对象进入老年区；<br> <code>4.动态判断对象的年龄</code>：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代；<br> <code>5.空间分配担保</code>：每次每次进行Minor GC时，JVM会计算Survivor区移至<strong>老年区的对象</strong>的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC，如果false则进行Full GC；    </li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;a href=&quot;#JVM内存结构（运行时数据区）&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构（运行时数据区）&quot;&gt;&lt;/a&gt;JVM内存结构（运行时数据区）&lt;/h3&gt;&lt;p&gt;JVM内存结构指得是：运行时数据区（Runtime Data Area），由 &lt;strong&gt;&lt;em&gt;方法区(Method Area) &lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;堆(Heap) &lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;Java栈(Java Stack) &lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;本地方法栈(Native Method Stack)&lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;程序计数器(Program Counter Register)&lt;/em&gt;&lt;/strong&gt;。&lt;br&gt;&lt;img src=&quot;http://p5vswdxl9.bkt.clouddn.com/JVMRuntime&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://edgeowner.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaCore（1）</title>
    <link href="http://edgeowner.com/2015/04/13/Java-Core/"/>
    <id>http://edgeowner.com/2015/04/13/Java-Core/</id>
    <published>2015-04-13T11:06:43.000Z</published>
    <updated>2015-04-14T12:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java核心"><a href="#Java核心" class="headerlink" title="Java核心"></a>Java核心</h2><h4 id="Java基本语法："><a href="#Java基本语法：" class="headerlink" title="Java基本语法："></a>Java基本语法：</h4><h4 id="Java类和对象："><a href="#Java类和对象：" class="headerlink" title="Java类和对象："></a>Java类和对象：</h4><h4 id="Java集合："><a href="#Java集合：" class="headerlink" title="Java集合："></a>Java集合：</h4><h4 id="Java泛型："><a href="#Java泛型：" class="headerlink" title="Java泛型："></a>Java泛型：</h4><h4 id="Java注解："><a href="#Java注解：" class="headerlink" title="Java注解："></a>Java注解：</h4><h4 id="Java反射："><a href="#Java反射：" class="headerlink" title="Java反射："></a>Java反射：</h4><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java核心&quot;&gt;&lt;a href=&quot;#Java核心&quot; class=&quot;headerlink&quot; title=&quot;Java核心&quot;&gt;&lt;/a&gt;Java核心&lt;/h2&gt;&lt;h4 id=&quot;Java基本语法：&quot;&gt;&lt;a href=&quot;#Java基本语法：&quot; class=&quot;headerlink&quot; title=&quot;Java基本语法：&quot;&gt;&lt;/a&gt;Java基本语法：&lt;/h4&gt;&lt;h4 id=&quot;Java类和对象：&quot;&gt;&lt;a href=&quot;#Java类和对象：&quot; class=&quot;headerlink&quot; title=&quot;Java类和对象：&quot;&gt;&lt;/a&gt;Java类和对象：&lt;/h4&gt;&lt;h4 id=&quot;Java集合：&quot;&gt;&lt;a href=&quot;#Java集合：&quot; class=&quot;headerlink&quot; title=&quot;Java集合：&quot;&gt;&lt;/a&gt;Java集合：&lt;/h4&gt;&lt;h4 id=&quot;Java泛型：&quot;&gt;&lt;a href=&quot;#Java泛型：&quot; class=&quot;headerlink&quot; title=&quot;Java泛型：&quot;&gt;&lt;/a&gt;Java泛型：&lt;/h4&gt;&lt;h4 id=&quot;Java注解：&quot;&gt;&lt;a href=&quot;#Java注解：&quot; class=&quot;headerlink&quot; title=&quot;Java注解：&quot;&gt;&lt;/a&gt;Java注解：&lt;/h4&gt;&lt;h4 id=&quot;Java反射：&quot;&gt;&lt;a href=&quot;#Java反射：&quot; class=&quot;headerlink&quot; title=&quot;Java反射：&quot;&gt;&lt;/a&gt;Java反射：&lt;/h4&gt;
    
    </summary>
    
      <category term="Java" scheme="http://edgeowner.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://edgeowner.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>归并排序（Merge Sort）</title>
    <link href="http://edgeowner.com/2015/03/28/mergeSort/"/>
    <id>http://edgeowner.com/2015/03/28/mergeSort/</id>
    <published>2015-03-28T11:35:31.000Z</published>
    <updated>2015-03-28T12:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>归并过程为：比较$a[i]$和$b[j]$的大小，若$a[i]≤b[j]$，则将第一个有序表中的元素$a[i]$复制到$r[k]$中，并令$i$和$k$分别加上$1$；否则将第二个有序表中的元素$b[j]$复制到$r[k]$中，并令$j$和$k$分别加上$1$，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到$r$中从下标$k$到下标$t$的单元。归并排序的算法我们通常用递归实现，先把待排序区间$[s,t]$以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间$[s,t]$。</p><hr><a id="more"></a><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>Selection Sort、Bubble Sort、Insertion Sort is $O(n^2)$ in average case , Merge Sort $O(n log(n))$ in worst case.</p><ol><li>In this sorting algorithm we use the idea of divide and conquer. We divide the array into two parts, sort them and then merge them to get the elements in ascending or descending order. Merge sorting is done recursively.</li><li>We take an array and keep dividing from the middle till we get only one element in each halves(sub-array).</li><li>The we sort the sub-arrays and join (merge) them back to get the final sorted array.</li></ol><blockquote><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤3直到某一指针超出序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol></blockquote><p><strong>总结</strong>：</p><ul><li>将两个已排好序的数组合并成一个有序的数组,称之为归并排序；</li><li>步骤：遍历两个数组，比较它们的值。谁比较小，谁先放入大数组中，直到数组遍历完成；</li></ul><p>算法动态展示</p><ol><li><a href="https://www.youtube.com/watch?v=7zuGmKfUt7s&amp;t=15s" target="_blank" rel="noopener">YouTube视频源地址</a> ;</li><li><a href="https://www.youtube.com/watch?v=e5ik2UGjHBk" target="_blank" rel="noopener">Merge Sort - step by step guide</a>;<br><strong><em>In this video beg and end are pointing at array index not the value at the array index.﻿ </em></strong></li><li><a href="https://www.youtube.com/watch?v=qdv3i6X0PiQ" target="_blank" rel="noopener">开课老师视频源</a>; </li><li><a href="https://www.youtube.com/watch?v=TzeBrDU-JaY&amp;t=319s" target="_blank" rel="noopener">MycodeSchool</a> </li><li><div id="dplayer4" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/mergeSort.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></li></ol><hr><h4 id="代码实现方式"><a href="#代码实现方式" class="headerlink" title="代码实现方式"></a>代码实现方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 归并排序</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arrs</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arrs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (arrs == <span class="keyword">null</span> || arrs.length == <span class="number">0</span> || arrs.length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mergeSort(arrs, <span class="number">0</span>, arrs.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 归并排序核心部分(递归调用)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arrs</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arrs, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//如果只有一个元素就不用排序</span></span><br><span class="line">      <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//取消中间数，进行拆分</span></span><br><span class="line">          <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">          <span class="comment">//左边的数不断进行拆分</span></span><br><span class="line">          mergeSort(arrs, left, middle);</span><br><span class="line">          <span class="comment">//右边的数不断进行拆分</span></span><br><span class="line">          mergeSort(arrs, middle + <span class="number">1</span>, right);</span><br><span class="line">          <span class="comment">//合并</span></span><br><span class="line">          merge(arrs, left, middle + <span class="number">1</span>, right);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 合并数组</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arrs</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> left   指向数组第一个元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> middle 指向数组分隔的元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> right  指向数组最后的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arrs, <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//左边的数组大小</span></span><br><span class="line">      <span class="keyword">int</span>[] leftArrs = <span class="keyword">new</span> <span class="keyword">int</span>[middle - left];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//右边的数组大小</span></span><br><span class="line">      <span class="keyword">int</span>[] rightArrs = <span class="keyword">new</span> <span class="keyword">int</span>[right - middle + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//往这两个数组填充数据</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; middle; i++) &#123;</span><br><span class="line">          leftArrs[i - left] = arrs[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = middle; i &lt;= right; i++) &#123;</span><br><span class="line">          rightArrs[i - middle] = arrs[i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//arrs数组的第一个元素</span></span><br><span class="line">      <span class="keyword">int</span> k = left;</span><br><span class="line">      <span class="comment">//比较两个数组的值，哪个小，就往数组上放</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; leftArrs.length &amp;&amp; j &lt; rightArrs.length) &#123;</span><br><span class="line">          <span class="comment">//谁比较小，谁将元素放入大数组中，移动指针，继续比较下一个</span></span><br><span class="line">          <span class="keyword">if</span> (leftArrs[i] &lt; rightArrs[j]) &#123;</span><br><span class="line">              arrs[k] = leftArrs[i];</span><br><span class="line">              i++;</span><br><span class="line">              k++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              arrs[k] = rightArrs[j];</span><br><span class="line">              j++;</span><br><span class="line">              k++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; leftArrs.length) &#123;</span><br><span class="line">          arrs[k] = leftArrs[i];</span><br><span class="line">          i++;</span><br><span class="line">          k++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果右边的数组还没比较晚，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">      <span class="keyword">while</span> (j &lt; rightArrs.length) &#123;</span><br><span class="line">          arrs[k] = rightArrs[j];</span><br><span class="line">          k++;</span><br><span class="line">          j++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>参考地址：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484058&amp;idx=1&amp;sn=432c2dd8e4bda662ce066c09f8e22bda&amp;chksm=ebd7439bdca0ca8ded40d0f431db411928936db9b4b5f5595027c8acd2efdef5ba35348641d2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">归并排序</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h3&gt;&lt;p&gt;归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。&lt;/p&gt;
&lt;p&gt;归并过程为：比较$a[i]$和$b[j]$的大小，若$a[i]≤b[j]$，则将第一个有序表中的元素$a[i]$复制到$r[k]$中，并令$i$和$k$分别加上$1$；否则将第二个有序表中的元素$b[j]$复制到$r[k]$中，并令$j$和$k$分别加上$1$，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到$r$中从下标$k$到下标$t$的单元。归并排序的算法我们通常用递归实现，先把待排序区间$[s,t]$以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间$[s,t]$。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://edgeowner.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://edgeowner.com/tags/Algorithms/"/>
    
      <category term="Sort" scheme="http://edgeowner.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>基数排序（Radix Sort）</title>
    <link href="http://edgeowner.com/2015/03/27/radixSort/"/>
    <id>http://edgeowner.com/2015/03/27/radixSort/</id>
    <published>2015-03-27T02:35:31.000Z</published>
    <updated>2015-03-27T12:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序(radix sort)属于”分配式排序”(distribution sort)，又称”桶子法”(bucket sort)或bin sort，将要排序的元素分配至某些”桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为$O(n log(r)m)$，其中$r$为所采取的基数，而$m$为堆数，空间复杂度$O(N)$，在某些时候，基数排序法的效率高于其它的稳定性排序法。<br><code>基数排序是按照分配，回收（分配到不同的位置上，然后回收）...不断分配...回收来进行排序，直到有序...。</code></p><hr><a id="more"></a><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>It is a sorting algorithm that is used to sort numbers. We sort the numbers from least significant digit to the most significant digit.</p><ol><li>When we are sorting the numbers we will first find the number of digits in the biggest number.</li><li>If there are N digits in the biggest number then we will need to perform N number of pass.</li><li>We will pad the remaining numbers with leading zeros so they all have N digits.</li><li>Then we will take 10 buckets labeled 0 to 9 and sort the numbers.</li><li>After the sorting is complete we will remove the leading zeros.</li></ol><p>基数排序的要点就两个：</p><blockquote><ol><li>分配：按照元素的大小来放入不同的桶子里；</li><li>回收：将桶子里的元素按桶子顺序重新放到数组中；</li><li>重复…..两个步骤；<br><strong><em> 基数排序对有负数和0的数列难以进行排序 </em></strong></li></ol></blockquote><p>算法动态展示</p><ol><li><a href="https://www.youtube.com/watch?v=nu4gDuFabIM" target="_blank" rel="noopener">YouTube视频源地址</a> ;</li><li><a href="https://www.youtube.com/watch?v=YXFI4osELGU" target="_blank" rel="noopener">Radix Sort - step by step guide</a>;</li><li><a href="https://www.youtube.com/watch?v=xhr26ia4k38" target="_blank" rel="noopener">开课老师视频源</a>; </li><li><div id="dplayer5" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer5"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/QQ20180403-113850-HD.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></li></ol><hr><h4 id="代码实现方式"><a href="#代码实现方式" class="headerlink" title="代码实现方式"></a>代码实现方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 基数排序</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> arrs</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arrs)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> max = findMax(arrs, <span class="number">0</span>, arrs.length - <span class="number">1</span>);</span><br><span class="line">     <span class="comment">//需要遍历的次数由数组最大的位数来决定</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; max / i &gt; <span class="number">0</span>; i = i * <span class="number">10</span>) &#123;</span><br><span class="line">         <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[arrs.length][<span class="number">10</span>];</span><br><span class="line">         <span class="comment">//获取每一个数字（个、十、百、千位...分配到桶子里）</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arrs.length; j++) &#123;</span><br><span class="line">             <span class="keyword">int</span> num = (arrs[j] / i) % <span class="number">10</span>;</span><br><span class="line">             <span class="comment">//将其放入桶子里</span></span><br><span class="line">             buckets[j][num] = arrs[j];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//回收桶子里的元素</span></span><br><span class="line">         <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">         <span class="comment">//有10个桶子</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">             <span class="comment">//对每个桶子里的元素进行回收</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; arrs.length; l++) &#123;</span><br><span class="line">                 <span class="comment">//如果桶子里有元素就回收(数据会初始化为0)</span></span><br><span class="line">                 <span class="keyword">if</span> (buckets[l][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                     arrs[k++] = buckets[l][j];</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 递归找出数组最大值</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> arrs  数组</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> left  左边界，第一个数</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> right 右边界，数组长度</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span>[] arrs, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//若该数组只有一个数，那么最大的就是该数组第一个值</span></span><br><span class="line">     <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">         <span class="keyword">return</span> arrs[left];</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> leftValue = arrs[left];</span><br><span class="line">         <span class="comment">//找出所有元素中的最大值</span></span><br><span class="line">         <span class="keyword">int</span> rightvalue = findMax(arrs, left + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (leftValue &gt; rightvalue) &#123;</span><br><span class="line">             <span class="keyword">return</span> leftValue;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> rightvalue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><p>参考地址：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484071&amp;idx=2&amp;sn=5195363e7a5c5e3e7cac2a733c2695e9&amp;chksm=ebd743a6dca0cab0b79aec38ff835116af9079114c9266ef673c6c1009b32b2abf262bf35e0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">基数排序</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基数排序&quot;&gt;&lt;a href=&quot;#基数排序&quot; class=&quot;headerlink&quot; title=&quot;基数排序&quot;&gt;&lt;/a&gt;基数排序&lt;/h3&gt;&lt;p&gt;基数排序(radix sort)属于”分配式排序”(distribution sort)，又称”桶子法”(bucket sort)或bin sort，将要排序的元素分配至某些”桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为$O(n log(r)m)$，其中$r$为所采取的基数，而$m$为堆数，空间复杂度$O(N)$，在某些时候，基数排序法的效率高于其它的稳定性排序法。&lt;br&gt;&lt;code&gt;基数排序是按照分配，回收（分配到不同的位置上，然后回收）...不断分配...回收来进行排序，直到有序...。&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://edgeowner.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://edgeowner.com/tags/Algorithms/"/>
    
      <category term="Sort" scheme="http://edgeowner.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>计数排序（Counting Sort）</title>
    <link href="http://edgeowner.com/2015/03/27/countingSort/"/>
    <id>http://edgeowner.com/2015/03/27/countingSort/</id>
    <published>2015-03-27T02:30:31.000Z</published>
    <updated>2015-03-27T03:30:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序是一种稳定的<strong>线性时间排序算法</strong>。计数排序使用一个额外的数组 $C$ ，其中第i个元素是待排序数组 $A$中值等于 $i$ 的元素的个数。然后根据数组 $C$ 来将 $A$ 中的元素排到正确的位置。<br>当输入的元素是 $n$ 个 $0$到 $k$ 之间的整数时，它的运行时间是 $\Theta (n+k)$ 。计数排序不是比较排序，排序的速度快于任何比较排序算法。<br>由于用来计数的数组$C$ 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 $1$），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序$0$到 $100$ 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序算法中，能够更有效的排序数据范围很大的数组。</p><ol><li>计数排序(Counting Sort)是一种$O(n)$的排序算法，其思路是开一个长度为$maxValue-minValue+1$的数组，然后分配。扫描一遍原始数组，以当前值$-minValue$作为下标，将该下标的计数器增$1$。</li><li>收集。扫描一遍计数器数组，按顺序把值收集起来。</li><li>计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序。</li></ol><a id="more"></a><hr><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>Counting sort is a sorting technique based on keys between a specific range, it works by counting the number of objects having distinct key values.Then doing some arithmetic to calculate the position of each object in the output sequence.</p><ol><li>Create a count array to store the count of each unique object;</li><li>Initially the count of all elements is zero ;</li><li>Count each elements in the given array and  place the count at the appropriate index;</li><li>Modify the count array by adding the previous counts;</li><li>Corresponding values represent the places in the count array;</li><li>We place the objects in their correct positions and decrease the count by one;</li></ol><p><em>翻译</em></p><blockquote><ol><li>找出待排序的中最大元素和最小元素；</li><li>统计数组中每个值为 $i$ 的元素出现的次数，存入数组 $C$的第$i$项；</li><li>对所有的技术累加（ $C$ 中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组；将每个元素 $i$ i放在新数组的第$C[i]$项，每放一个元素就将 $C[i]$减去$1$ ；</li></ol></blockquote><p>算法动态展示</p><ol><li><a href="https://www.youtube.com/watch?v=7zuGmKfUt7s&amp;t=15s" target="_blank" rel="noopener">YouTube视频源地址</a> ;</li><li><a href="https://www.youtube.com/watch?v=TTnvXY82dtM" target="_blank" rel="noopener">Counting Sort - step by step guide</a>;</li><li><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/QQ20180402-174913-HD.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></li></ol><hr><h4 id="代码实现方式"><a href="#代码实现方式" class="headerlink" title="代码实现方式"></a>代码实现方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计数排序 </span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arrs</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arrs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] copyData = Arrays.copyOf(arrs, arrs.length);</span><br><span class="line">       <span class="keyword">int</span> maxValue = arrs[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> minValue = arrs[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; copyData.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (copyData[i] &gt; maxValue) &#123;</span><br><span class="line">               maxValue = copyData[i];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (copyData[i] &lt; minValue) &#123;</span><br><span class="line">               minValue = copyData[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> range = maxValue - minValue + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[range];</span><br><span class="line">       Arrays.fill(counts, <span class="number">0</span>);</span><br><span class="line">       <span class="comment">//  计算数组中每个值和最小值的差，并计数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> arr : copyData) &#123;</span><br><span class="line">           counts[arr - minValue]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 得到数组中大于某个数的值一共有多少个</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">           counts[i] = counts[i] + counts[i - <span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 根据数量放置值，每放置一个，对应的值的数量减一</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; copyData.length; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> index = copyData[i] - minValue;</span><br><span class="line">           arrs[counts[index] - <span class="number">1</span>] = copyData[i];</span><br><span class="line">           counts[index]--;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>参考地址：<a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/8.countingSort.md" target="_blank" rel="noopener">计数排序</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;计数排序&quot;&gt;&lt;a href=&quot;#计数排序&quot; class=&quot;headerlink&quot; title=&quot;计数排序&quot;&gt;&lt;/a&gt;计数排序&lt;/h3&gt;&lt;p&gt;计数排序是一种稳定的&lt;strong&gt;线性时间排序算法&lt;/strong&gt;。计数排序使用一个额外的数组 $C$ ，其中第i个元素是待排序数组 $A$中值等于 $i$ 的元素的个数。然后根据数组 $C$ 来将 $A$ 中的元素排到正确的位置。&lt;br&gt;当输入的元素是 $n$ 个 $0$到 $k$ 之间的整数时，它的运行时间是 $\Theta (n+k)$ 。计数排序不是比较排序，排序的速度快于任何比较排序算法。&lt;br&gt;由于用来计数的数组$C$ 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 $1$），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序$0$到 $100$ 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序算法中，能够更有效的排序数据范围很大的数组。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计数排序(Counting Sort)是一种$O(n)$的排序算法，其思路是开一个长度为$maxValue-minValue+1$的数组，然后分配。扫描一遍原始数组，以当前值$-minValue$作为下标，将该下标的计数器增$1$。&lt;/li&gt;
&lt;li&gt;收集。扫描一遍计数器数组，按顺序把值收集起来。&lt;/li&gt;
&lt;li&gt;计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://edgeowner.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://edgeowner.com/tags/Algorithms/"/>
    
      <category term="Sort" scheme="http://edgeowner.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序（Shell Sort）</title>
    <link href="http://edgeowner.com/2015/03/25/shellSort/"/>
    <id>http://edgeowner.com/2015/03/25/shellSort/</id>
    <published>2015-03-25T01:15:31.000Z</published>
    <updated>2015-03-25T12:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序也称为递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是基于插入排序的一下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经安排好序的数据操作时，效率高，即可达到线性排序的效率</li><li>插入排序一般来说是抵消的，因为插入排序每次只能将数据移动一位<br>从专业的角度上讲，将一个序列分成好几个序列，用一个数来表示：那个数称为增量。显然的是，增量是不断递减的(直到增量为$1$)</li></ul><p>希尔排序的平均复杂度是$O(N*logN)~O(N^2)$，最好的情况$O(N^1.3)$，最坏的情况$O(N^2)$；空间复杂度$O(1)$;不稳定算法</p><hr><a id="more"></a><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>In this sorting algorithm we compare elements that are distant apart rather than adjacent. Shell sort is like insertion sort.</p><ol><li>We start by comparing elements that are at a certain distance apart.So if there are <strong>N</strong> elements then we start with a value <strong>gap &lt; N</strong></li><li>In each pass we keep reducing the value of gap till we reach the last pass when gap is 1</li><li><strong>Note!</strong>, when gap = 1,shell sort is like insertion sort and we will have sorted elements at the end of this pass;</li></ol><p>算法动态展示</p><ol><li><a href="https://www.youtube.com/watch?v=SHcPqUe2GZM" target="_blank" rel="noopener">YouTube视频源地址</a> ;</li><li><a href="https://www.youtube.com/watch?v=SCBf7aqKQEY&amp;t=36s" target="_blank" rel="noopener">Shell Sort - step by step guide</a>;</li><li><a href="https://www.youtube.com/watch?v=ddeLSDsYVp8" target="_blank" rel="noopener">开课老师视频源</a>;</li><li><div id="dplayer6" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer6"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/QQ20180328-201843-HD.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></li></ol><hr><h4 id="代码实现方式"><a href="#代码实现方式" class="headerlink" title="代码实现方式"></a>代码实现方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 希尔排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arrs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arrs == <span class="keyword">null</span> || arrs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//增量 每次都 gap/2   gap为每次外循环的步长</span></span><br><span class="line">        <span class="comment">//当 步长为 1 即增量为1 时， 希尔排序蜕化为 简单插入排序</span></span><br><span class="line">        <span class="keyword">int</span> counterFrequency = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = (<span class="keyword">int</span>) Math.floor(arrs.length / <span class="number">2</span>); gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            counterFrequency++;</span><br><span class="line">            System.out.println(<span class="string">"------------------1.Outerloop  start---------------------"</span>);</span><br><span class="line">            System.out.println(MessageFormat.format(<span class="string">"--------1.Increment:&#123;0&#125;, outerloop frequency:&#123;1&#125;---------"</span>, gap, counterFrequency));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arrs.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">int</span> temp = arrs[j];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// j - step 就是代表与它同组隔壁的元素 内层增量 gap通过 j-gap确定左边</span></span><br><span class="line">                <span class="keyword">int</span> counterSwapJGap = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; arrs[j - gap] &gt; temp) &#123;</span><br><span class="line">                    arrs[j] = arrs[j - gap];</span><br><span class="line">                    j = j - gap;</span><br><span class="line">                    counterSwapJGap++;</span><br><span class="line">                    printArr(<span class="string">"--------------1. arrs:&#123;0&#125;---------------"</span>,arrs);</span><br><span class="line">                &#125;</span><br><span class="line">                printArr(<span class="string">"--------------2. arrs:&#123;0&#125;---------------"</span>,arrs);</span><br><span class="line">                System.out.println(MessageFormat.format(<span class="string">"------------------3.Whileloop counter:&#123;0&#125;---------------------"</span>, counterSwapJGap));</span><br><span class="line">                arrs[j] = temp;</span><br><span class="line">                System.out.println(MessageFormat.format(<span class="string">"--------2.Innerloop: i:&#123;0&#125;, j:&#123;1&#125; , temp:&#123;2&#125; ---------"</span>, i, j, temp));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"------------------1.Outerloop  over---------------------"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对比简单插入排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单插入排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arrs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSortDemo</span><span class="params">(<span class="keyword">int</span> arrs[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arrs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len - <span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arrs[j] &lt; arrs[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arrs[j];</span><br><span class="line">                    arrs[j] = arrs[j - <span class="number">1</span>];</span><br><span class="line">                    arrs[j - <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arrs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">(String str, <span class="keyword">int</span>[] arrs)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"["</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrs.length; i++) &#123;</span><br><span class="line">                sb.append(<span class="string">","</span> + arrs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">"]"</span>);</span><br><span class="line">            result = sb.toString().replaceFirst(<span class="string">","</span>, <span class="string">""</span>);</span><br><span class="line">            result = MessageFormat.format(str, result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(<span class="string">"["</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrs.length; i++) &#123;</span><br><span class="line">                sb.append(<span class="string">","</span> + arrs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">"]"</span>);</span><br><span class="line">            result = sb.toString().replaceFirst(<span class="string">","</span>, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"result:"</span> + result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>参考地址：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484071&amp;idx=1&amp;sn=c372ab46daf1ccdf27398951172c4443&amp;chksm=ebd743a6dca0cab03a55772a6f64be89f9dee504a9e00f96b36e685698722ade9855d8bd3c21#rd" target="_blank" rel="noopener">希尔排序</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;希尔排序&quot;&gt;&lt;a href=&quot;#希尔排序&quot; class=&quot;headerlink&quot; title=&quot;希尔排序&quot;&gt;&lt;/a&gt;希尔排序&lt;/h3&gt;&lt;p&gt;希尔排序也称为递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是基于插入排序的一下两点性质而提出改进方法的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入排序在对几乎已经安排好序的数据操作时，效率高，即可达到线性排序的效率&lt;/li&gt;
&lt;li&gt;插入排序一般来说是抵消的，因为插入排序每次只能将数据移动一位&lt;br&gt;从专业的角度上讲，将一个序列分成好几个序列，用一个数来表示：那个数称为增量。显然的是，增量是不断递减的(直到增量为$1$)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;希尔排序的平均复杂度是$O(N*logN)~O(N^2)$，最好的情况$O(N^1.3)$，最坏的情况$O(N^2)$；空间复杂度$O(1)$;不稳定算法&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://edgeowner.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://edgeowner.com/tags/Algorithms/"/>
    
      <category term="Sort" scheme="http://edgeowner.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>堆排序（Heap Sort）</title>
    <link href="http://edgeowner.com/2015/03/24/heapSort/"/>
    <id>http://edgeowner.com/2015/03/24/heapSort/</id>
    <published>2015-03-24T02:12:31.000Z</published>
    <updated>2015-03-24T14:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。<br>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。<br>大堆小堆图例：<br><img src="http://p5vswdxl9.bkt.clouddn.com/%E5%A4%A7%E5%A0%86%E5%B0%8F%E5%A0%86.png" alt=""><br>简单来说：堆排序是将数据看成是完全二叉树、根据完全二叉树的特性来进行排序的一种算法。<br>最大堆要求节点的元素都要不小于其孩子，最小堆要求节点元素都不大于其左右孩子。那么处于最大堆的根节点的元素一定是这个堆中的最大值。<br>完全二叉树有个特性：左边子节点位置 = 当前父节点的两倍 + 1，右边子节点位置 = 当前父节点的两倍 + 2<br><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484064&amp;idx=2&amp;sn=d308d573df43e8e3b0633d0dc1147c3b&amp;chksm=ebd743a1dca0cab774e7df348401039dda0765923efde0b9cf8e3589c4ceab25c5ec0cea5f7d#rd" target="_blank" rel="noopener">点击参考文章</a></p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>这里我们讨论最大堆：当前每个父节点都大于子节点。<br>In this Algorithm we first build the heap using the given elements, We create a Max Heap to sort the elements in ascending order , Once the heap is<br>created we swap the root node with the last node an delete the last node from the heap。</p><ol><li>Build a heap we need transform it into to a max  heap ;</li><li>Create a Max heap (this Max heap parent node is always greater than or equal to child nodes);</li><li>Remove the node ,in anther way :Swap first and last node and delete the last node from heap;</li><li>Repeat the 1,2,3 step ,always build the max heap;</li></ol><p>算法动态展示：</p><ol><li><a href="https://www.youtube.com/watch?v=MtQL_ll5KhQ&amp;t=26s" target="_blank" rel="noopener">YouTube视频源地址</a></li><li><a href="https://www.youtube.com/watch?v=51JGP4VVlDc&amp;t=276s" target="_blank" rel="noopener">Heap Sort - step by step guide</a>;</li><li><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/QQ20180328-140208-HD.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></li></ol><hr><h4 id="代码实现方式"><a href="#代码实现方式" class="headerlink" title="代码实现方式"></a>代码实现方式</h4><p>(关键节点添加输出标注，可自行追踪执行过程)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 堆排序</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arrs</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arrs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arrs == <span class="keyword">null</span> || arrs.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> len = arrs.length;</span><br><span class="line">       <span class="comment">//循环建立最大堆</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">           System.out.println(MessageFormat.format(<span class="string">"1. heapSort: i,&#123;0&#125;  j,&#123;1&#125;"</span>, i, len - <span class="number">1</span>));</span><br><span class="line">           System.out.println(<span class="string">"--------------1. buildMaxHeap start--------------"</span>);</span><br><span class="line">           buildMaxHeap(arrs, len - i);</span><br><span class="line">           <span class="comment">//交换堆顶和最后一个元素</span></span><br><span class="line">           <span class="keyword">int</span> temp = arrs[<span class="number">0</span>];</span><br><span class="line">           arrs[<span class="number">0</span>] = arrs[len - <span class="number">1</span> - i];</span><br><span class="line">           arrs[len - <span class="number">1</span> - i] = temp;</span><br><span class="line">           System.out.println(<span class="string">"--------------1. buildMaxHeap over--------------"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 完成最大堆建立</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arrs</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] arrs, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"--------------2. buildMaxHeap method start--------------"</span>);</span><br><span class="line">       System.out.println(MessageFormat.format(<span class="string">"--------------2. params:&#123;0&#125;--------------"</span>,len));</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="keyword">int</span>) Math.floor(len / <span class="number">2</span>); j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">           heapify(arrs, j, len);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 建立堆 (大顶堆方式)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arrs           完全二叉树</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> currentRooNode 当前父节点位置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> length         节点总数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arrs, <span class="keyword">int</span> currentRooNode, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"--------------3. heapify method start--------------"</span>);</span><br><span class="line">       System.out.println(MessageFormat.format(<span class="string">"--------------3. params:&#123;0&#125;,&#123;1&#125;-------------"</span>, currentRooNode, length));</span><br><span class="line">       <span class="keyword">if</span> (currentRooNode &lt; length) &#123;</span><br><span class="line">           <span class="comment">//左叶子结点 位置</span></span><br><span class="line">           <span class="keyword">int</span> left = <span class="number">2</span> * currentRooNode + <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//右叶子结点 位置</span></span><br><span class="line">           <span class="keyword">int</span> right = <span class="number">2</span> * currentRooNode + <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">int</span> max = currentRooNode;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (left &lt; length) &#123;</span><br><span class="line">               <span class="comment">//如果当前根节点的 左叶子节点元素值较大，记录它的位置</span></span><br><span class="line">               <span class="keyword">if</span> (arrs[max] &lt; arrs[left]) &#123;</span><br><span class="line">                   max = left;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (right &lt; length) &#123;</span><br><span class="line">               <span class="comment">//如果当前根节点的 右叶子节点元素值较大，记录它的位置</span></span><br><span class="line">               <span class="keyword">if</span> (arrs[max] &lt; arrs[right]) &#123;</span><br><span class="line">                   max = right;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//如果最大的不是根元素位置，那么就交换</span></span><br><span class="line">           <span class="keyword">if</span> (max != currentRooNode) &#123;</span><br><span class="line">               <span class="keyword">int</span> temp = arrs[max];</span><br><span class="line">               arrs[max] = arrs[currentRooNode];</span><br><span class="line">               arrs[currentRooNode] = temp;</span><br><span class="line">               <span class="comment">//继续比较，直到完成一次建堆</span></span><br><span class="line">               heapify(arrs, max, length);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"--------------3. heapify method over--------------"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>参考地址：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484064&amp;idx=2&amp;sn=d308d573df43e8e3b0633d0dc1147c3b&amp;chksm=ebd743a1dca0cab774e7df348401039dda0765923efde0b9cf8e3589c4ceab25c5ec0cea5f7d#rd" target="_blank" rel="noopener">堆排序</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h3&gt;&lt;p&gt;堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。&lt;br&gt;堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。&lt;br&gt;大堆小堆图例：&lt;br&gt;&lt;img src=&quot;http://p5vswdxl9.bkt.clouddn.com/%E5%A4%A7%E5%A0%86%E5%B0%8F%E5%A0%86.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;简单来说：堆排序是将数据看成是完全二叉树、根据完全二叉树的特性来进行排序的一种算法。&lt;br&gt;最大堆要求节点的元素都要不小于其孩子，最小堆要求节点元素都不大于其左右孩子。那么处于最大堆的根节点的元素一定是这个堆中的最大值。&lt;br&gt;完全二叉树有个特性：左边子节点位置 = 当前父节点的两倍 + 1，右边子节点位置 = 当前父节点的两倍 + 2&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=2247484064&amp;amp;idx=2&amp;amp;sn=d308d573df43e8e3b0633d0dc1147c3b&amp;amp;chksm=ebd743a1dca0cab774e7df348401039dda0765923efde0b9cf8e3589c4ceab25c5ec0cea5f7d#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击参考文章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://edgeowner.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://edgeowner.com/tags/Algorithms/"/>
    
      <category term="Sort" scheme="http://edgeowner.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>快速排序（Quick Sort）</title>
    <link href="http://edgeowner.com/2015/03/24/quickSort/"/>
    <id>http://edgeowner.com/2015/03/24/quickSort/</id>
    <published>2015-03-24T02:10:31.000Z</published>
    <updated>2015-03-24T14:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是冒泡排序的改进版，是最好的一种内排序，面试会经常被问到，是程序员必须掌握的。</p><hr><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>快速排一般基于递归实现：</p><ol><li>选定一个合适的值（理想情况中值最好。实现中一般使用数组第一个值），称为“枢轴”（pivot）。</li><li>基于这个值，将数组分为两部分，较小的分在左边，较大的分在右边。</li><li>一轮下来，这个枢轴的位置一定在最终位置上。</li><li>对两个子数组分别重复上述过程，直到每个数组只有一个元素。</li><li>排序完成。</li></ol><a id="more"></a><hr><h4 id="快速排序示意图："><a href="#快速排序示意图：" class="headerlink" title="快速排序示意图："></a>快速排序示意图：</h4><p><img src="http://p5vswdxl9.bkt.clouddn.com/Sorting_quicksort_anim.gif" alt=""><br>图例过程演示（<a href="https://www.bilibili.com/video/av12540893?from=search&amp;seid=6178581465044594405" target="_blank" rel="noopener">中文原视频地址</a>）：</p><ol><li><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/QQ20180327-124320-HD.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></li><li><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/QQ20180327-124538-HD.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></li><li><a href="https://www.youtube.com/watch?v=ywWBy6J5gz8" target="_blank" rel="noopener">超有趣的快速排序视频</a></li></ol><hr><h4 id="代码实现方式（为了更直观的反映整个排序过程添加了标记代码）："><a href="#代码实现方式（为了更直观的反映整个排序过程添加了标记代码）：" class="headerlink" title="代码实现方式（为了更直观的反映整个排序过程添加了标记代码）："></a>代码实现方式（为了更直观的反映整个排序过程添加了标记代码）：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果left不小于right ，需要排序的部分只有一个元素，方法返回</span></span><br><span class="line">       System.out.println(<span class="string">"left:"</span> + left + <span class="string">",right:"</span> + right);</span><br><span class="line">       <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">"i=j=0"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"1.-------------------"</span>);</span><br><span class="line">       <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">           System.out.println(MessageFormat.format(<span class="string">"return: left,&#123;0&#125;  | right,&#123;1&#125;"</span>, left, right));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//设置最左边元素为基准点：pivot</span></span><br><span class="line">       <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">       System.out.println(<span class="string">"pivot:"</span> + pivot);</span><br><span class="line">       <span class="keyword">int</span> i = left;</span><br><span class="line">       <span class="keyword">int</span> j = right;</span><br><span class="line">       <span class="comment">//把要排序的序列中比p大的放到右边，比p小的放到左边，p的下标位置为i</span></span><br><span class="line">       <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">           System.out.println(<span class="string">"2.-------start------------"</span>);</span><br><span class="line">           <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) &#123;</span><br><span class="line">               j--;</span><br><span class="line">               System.out.println(<span class="string">"2.  j:"</span> + j);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"========[j-- over, i++ start ]=========="</span>);</span><br><span class="line">           <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">               i++;</span><br><span class="line">               System.out.println(<span class="string">"2.  i:"</span> + i);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"2.-------end------------"</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">               <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">               arr[i] = arr[j];</span><br><span class="line">               arr[j] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//交换基准点</span></span><br><span class="line">       arr[left] = arr[i];</span><br><span class="line">       arr[i] = pivot;</span><br><span class="line">       <span class="comment">//对序列中，i左边的元素实施快速排序</span></span><br><span class="line">       System.out.println(<span class="string">"左边开始前， right为"</span> + right + <span class="string">"值"</span>);</span><br><span class="line">       quickSort2(arr, left, i - <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//对序列中，j右边边的元素实施快速排序</span></span><br><span class="line">       System.out.println(<span class="string">"右块遍历开始...... "</span>);</span><br><span class="line">       quickSort2(arr, i + <span class="number">1</span>, right);</span><br><span class="line">       System.out.println(<span class="string">"left =:"</span> + (i + <span class="number">1</span>) + <span class="string">",right = "</span> + right);</span><br><span class="line">       System.out.println(<span class="string">"3.-------------------"</span>);</span><br><span class="line">       System.out.println(<span class="string">"4.---------all over----------"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//大数据量测试</span></span><br><span class="line">       <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000</span>];</span><br><span class="line">       Random r = <span class="keyword">new</span> Random();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           arr[i] = r.nextInt(<span class="number">10000000</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">       quickSort(nums);</span><br><span class="line">       <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">       System.out.println(<span class="string">"-----------大数据量测试结果-----------"</span>);</span><br><span class="line">       System.out.println(<span class="string">"all time:"</span> + time + <span class="string">"毫秒"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>参考地址：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484039&amp;idx=1&amp;sn=15aa43a3865daca394abae379c7a5383&amp;chksm=ebd74386dca0ca90e3c3067515de1c3b3da7e0ea44a26d8dd96e8d7424f4e10227d9edac9bcf#rd" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h3&gt;&lt;p&gt;快速排序是冒泡排序的改进版，是最好的一种内排序，面试会经常被问到，是程序员必须掌握的。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;算法思路&quot;&gt;&lt;a href=&quot;#算法思路&quot; class=&quot;headerlink&quot; title=&quot;算法思路&quot;&gt;&lt;/a&gt;算法思路&lt;/h4&gt;&lt;p&gt;快速排一般基于递归实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选定一个合适的值（理想情况中值最好。实现中一般使用数组第一个值），称为“枢轴”（pivot）。&lt;/li&gt;
&lt;li&gt;基于这个值，将数组分为两部分，较小的分在左边，较大的分在右边。&lt;/li&gt;
&lt;li&gt;一轮下来，这个枢轴的位置一定在最终位置上。&lt;/li&gt;
&lt;li&gt;对两个子数组分别重复上述过程，直到每个数组只有一个元素。&lt;/li&gt;
&lt;li&gt;排序完成。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://edgeowner.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://edgeowner.com/tags/Algorithms/"/>
    
      <category term="Sort" scheme="http://edgeowner.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>排序算法之线性排序</title>
    <link href="http://edgeowner.com/2015/03/22/linear/"/>
    <id>http://edgeowner.com/2015/03/22/linear/</id>
    <published>2015-03-22T11:20:31.000Z</published>
    <updated>2015-03-23T13:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性排序："><a href="#线性排序：" class="headerlink" title="线性排序："></a>线性排序：</h2><p><strong><em>计数排序 </em></strong>、<strong><em>桶排序 </em></strong>、<strong><em>基数排序 </em></strong><br>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><blockquote><p>基数排序：根据键值的每位数字来分配桶；<br>计数排序：每个桶只存储单一键值；<br>桶排序：每个桶存储一定范围的数值； </p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="计数排序："><a href="#计数排序：" class="headerlink" title="计数排序："></a>计数排序：</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br><code>基本思想</code></p><p><code>遍历流程图例</code><br><img src="http://p5vswdxl9.bkt.clouddn.com/countingSort.gif" alt=""></p><p><code>代码实现</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] counterSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == arr || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> arr;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> maxValue = getMaxValue(arr);</span><br><span class="line">       <span class="keyword">return</span> countingSort(arr, maxValue);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countingSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> maxValue) &#123;</span><br><span class="line">       <span class="keyword">int</span> bucketLen = maxValue + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[bucketLen];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">           bucket[value]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> sortedIndex = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">           <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               arr[sortedIndex++] = j;</span><br><span class="line">               bucket[j]--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">           <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">               maxValue = value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="桶排序："><a href="#桶排序：" class="headerlink" title="桶排序："></a>桶排序：</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><blockquote><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中<br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</li></ol></blockquote><p><code>基本思想</code><br> 类似计数排序</p><p><code>遍历流程图例</code></p><p><code>代码实现</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桶值大小</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> BUCKET_SIZE = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> arr;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> minValue = arr[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">          <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">              minValue = value;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">              maxValue = value;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> bucketCount = (<span class="keyword">int</span>) Math.floor((maxValue - minValue) / BUCKET_SIZE) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">          <span class="keyword">int</span> index = (<span class="keyword">int</span>) Math.floor((arr[i] - minValue) / BUCKET_SIZE);</span><br><span class="line">          buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> arrIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span>[] bucket : buckets) &#123;</span><br><span class="line">          <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">          bucket = insertSort(bucket);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> value : bucket) &#123;</span><br><span class="line">              arr[arrIndex++] = value;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] arrAppend(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value) &#123;</span><br><span class="line">      arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">      arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 插入排序</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == arr || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> arr;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">          <span class="comment">// 从已经排序的序列最右边的开始比较，找到比其小的数</span></span><br><span class="line">          <span class="keyword">int</span> j = i;</span><br><span class="line">          <span class="comment">// 记录要插入的数据</span></span><br><span class="line">          <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">          <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">              arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">              j--;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 存在比其小的数，插入</span></span><br><span class="line">          <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">              arr[j] = tmp;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="基数排序："><a href="#基数排序：" class="headerlink" title="基数排序："></a>基数排序：</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。<br><code>基本思想</code></p><ol><li>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序；</li><li>分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中；</li><li>收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]；<br>对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束；</li><li>根据上述“基数排序”的展示，我们可以清楚的看到整个实现的过程</li></ol><p><code>LSD基数排序遍历流程图例</code><br><img src="http://p5vswdxl9.bkt.clouddn.com/radixSort.gif" alt=""></p><p><code>代码实现</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == arr || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> arr;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> maxDigit = getMaxDigit(arr);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> radixSort(arr, maxDigit);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取最高位数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxDigit</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> maxValue = getMaxValue(arr);</span><br><span class="line">       <span class="keyword">return</span> getNumLenght(maxValue);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumLenght</span><span class="params">(<span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> lenght = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">long</span> temp = num; temp != <span class="number">0</span>; temp /= <span class="number">10</span>) &#123;</span><br><span class="line">           lenght++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> lenght;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> maxDigit) &#123;</span><br><span class="line">       <span class="keyword">int</span> mod = <span class="number">10</span>;</span><br><span class="line">       <span class="keyword">int</span> dev = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">           <span class="comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">           <span class="keyword">int</span>[][] counter = <span class="keyword">new</span> <span class="keyword">int</span>[mod * <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">               <span class="keyword">int</span> bucket = ((arr[j] % mod) / dev) + mod;</span><br><span class="line">               counter[bucket] = arrayAppend(counter[bucket], arr[j]);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span>[] bucket : counter) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> value : bucket) &#123;</span><br><span class="line">                   arr[pos++] = value;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] arrayAppend(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value) &#123;</span><br><span class="line">       arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">       arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">           <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">               maxValue = value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线性排序：&quot;&gt;&lt;a href=&quot;#线性排序：&quot; class=&quot;headerlink&quot; title=&quot;线性排序：&quot;&gt;&lt;/a&gt;线性排序：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;计数排序 &lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;桶排序 &lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;基数排序 &lt;/em&gt;&lt;/strong&gt;&lt;br&gt;这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基数排序：根据键值的每位数字来分配桶；&lt;br&gt;计数排序：每个桶只存储单一键值；&lt;br&gt;桶排序：每个桶存储一定范围的数值； &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://edgeowner.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://edgeowner.com/tags/Algorithms/"/>
    
      <category term="Sort" scheme="http://edgeowner.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>排序算法之归并排序</title>
    <link href="http://edgeowner.com/2015/03/18/division-recursion/"/>
    <id>http://edgeowner.com/2015/03/18/division-recursion/</id>
    <published>2015-03-18T02:10:31.000Z</published>
    <updated>2015-03-19T12:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分治递归思想排序："><a href="#分治递归思想排序：" class="headerlink" title="分治递归思想排序："></a>分治递归思想排序：</h2><hr><h3 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h3><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><blockquote><p>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；<br>自下而上的迭代；</p></blockquote><p><code>基本思想</code></p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。<a id="more"></a></li></ol><p><code>遍历流程图例</code><br><img src="http://p5vswdxl9.bkt.clouddn.com/mergeSort.gif" alt=""></p><p><code>代码实现</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merger2Sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == arr || arr.length == <span class="number">0</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sort(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> middle = (<span class="keyword">int</span>) Math.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span>[] left = Arrays.copyOfRange(arr, <span class="number">0</span>, middle);</span><br><span class="line">    <span class="keyword">int</span>[] right = Arrays.copyOfRange(arr, middle, arr.length);</span><br><span class="line">    <span class="keyword">return</span> merge(sort(left), sort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result[i++] = left[<span class="number">0</span>];</span><br><span class="line">            left = Arrays.copyOfRange(left, <span class="number">1</span>, left.length);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i++] = right[<span class="number">0</span>];</span><br><span class="line">            right = Arrays.copyOfRange(right, <span class="number">1</span>, right.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result[i++] = left[<span class="number">0</span>];</span><br><span class="line">        left = Arrays.copyOfRange(left, <span class="number">1</span>, left.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result[i++] = right[<span class="number">0</span>];</span><br><span class="line">        right = Arrays.copyOfRange(right, <span class="number">1</span>, right.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。 </strong></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分治递归思想排序：&quot;&gt;&lt;a href=&quot;#分治递归思想排序：&quot; class=&quot;headerlink&quot; title=&quot;分治递归思想排序：&quot;&gt;&lt;/a&gt;分治递归思想排序：&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;归并排序：&quot;&gt;&lt;a href=&quot;#归并排序：&quot; class=&quot;headerlink&quot; title=&quot;归并排序：&quot;&gt;&lt;/a&gt;归并排序：&lt;/h3&gt;&lt;p&gt;归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。&lt;br&gt;作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；&lt;br&gt;自下而上的迭代；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;基本思想&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；&lt;/li&gt;
&lt;li&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置；&lt;/li&gt;
&lt;li&gt;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；&lt;/li&gt;
&lt;li&gt;重复步骤 3 直到某一指针达到序列尾；&lt;/li&gt;
&lt;li&gt;将另一序列剩下的所有元素直接复制到合并序列尾。
    
    </summary>
    
      <category term="Algorithms" scheme="http://edgeowner.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://edgeowner.com/tags/Algorithms/"/>
    
      <category term="Sort" scheme="http://edgeowner.com/tags/Sort/"/>
    
  </entry>
  
</feed>
