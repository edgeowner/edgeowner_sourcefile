<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>edgeowner</title>
  
  <subtitle>多读书，读好书，少写bug</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://edgeowner.com/"/>
  <updated>2018-04-18T09:15:57.944Z</updated>
  <id>http://edgeowner.com/</id>
  
  <author>
    <name>ZhangSunny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>concurrent source code read</title>
    <link href="http://edgeowner.com/2018/04/18/ConcurrentSourceCodeRead/concurrent-source-code-read/"/>
    <id>http://edgeowner.com/2018/04/18/ConcurrentSourceCodeRead/concurrent-source-code-read/</id>
    <published>2018-04-18T09:15:57.000Z</published>
    <updated>2018-04-18T09:15:57.944Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring source code read</title>
    <link href="http://edgeowner.com/2018/04/18/SpringSourceCodeRead/spring-source-code-read/"/>
    <id>http://edgeowner.com/2018/04/18/SpringSourceCodeRead/spring-source-code-read/</id>
    <published>2018-04-18T09:14:21.000Z</published>
    <updated>2018-04-18T09:14:21.072Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDK source code read</title>
    <link href="http://edgeowner.com/2018/04/18/JDKSourceCodeRead/JDK-source-code-read/"/>
    <id>http://edgeowner.com/2018/04/18/JDKSourceCodeRead/JDK-source-code-read/</id>
    <published>2018-04-18T09:13:46.000Z</published>
    <updated>2018-04-18T09:13:46.227Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java序列化</title>
    <link href="http://edgeowner.com/2018/03/13/JavaPremium/Java%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://edgeowner.com/2018/03/13/JavaPremium/Java序列化/</id>
    <published>2018-03-13T12:06:04.000Z</published>
    <updated>2018-03-14T02:28:55.234Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://edgeowner.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://edgeowner.com/tags/Java/"/>
    
      <category term="Serialize" scheme="http://edgeowner.com/tags/Serialize/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO</title>
    <link href="http://edgeowner.com/2018/03/13/JavaPremium/Java-NIO/"/>
    <id>http://edgeowner.com/2018/03/13/JavaPremium/Java-NIO/</id>
    <published>2018-03-13T12:05:28.000Z</published>
    <updated>2018-03-14T02:35:31.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java LDAP</title>
    <link href="http://edgeowner.com/2018/03/13/JavaPremium/Java-LDAP/"/>
    <id>http://edgeowner.com/2018/03/13/JavaPremium/Java-LDAP/</id>
    <published>2018-03-13T12:05:05.000Z</published>
    <updated>2018-03-14T02:35:23.955Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java CAS</title>
    <link href="http://edgeowner.com/2018/03/13/JavaPremium/Java-CAS/"/>
    <id>http://edgeowner.com/2018/03/13/JavaPremium/Java-CAS/</id>
    <published>2018-03-13T12:04:50.000Z</published>
    <updated>2018-03-19T10:37:03.986Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mysql索引介绍</title>
    <link href="http://edgeowner.com/2017/05/06/Mysql/mysql-index/"/>
    <id>http://edgeowner.com/2017/05/06/Mysql/mysql-index/</id>
    <published>2017-05-06T11:23:43.000Z</published>
    <updated>2017-05-06T13:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://segmentfault.com/a/1190000012773157" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/11
      
    
    </summary>
    
      <category term="示例代码" scheme="http://edgeowner.com/categories/%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Code" scheme="http://edgeowner.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://edgeowner.com/2017/05/06/DesignPattern/SingletonPattern/"/>
    <id>http://edgeowner.com/2017/05/06/DesignPattern/SingletonPattern/</id>
    <published>2017-05-06T10:23:43.000Z</published>
    <updated>2017-05-06T13:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="http://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">单例模式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/design-
      
    
    </summary>
    
      <category term="示例代码" scheme="http://edgeowner.com/categories/%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Code" scheme="http://edgeowner.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>浅析线程安全</title>
    <link href="http://edgeowner.com/2017/03/02/JavaMultiThread/thread-safety-demo/"/>
    <id>http://edgeowner.com/2017/03/02/JavaMultiThread/thread-safety-demo/</id>
    <published>2017-03-02T14:13:25.000Z</published>
    <updated>2017-03-02T14:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;
      
    
    </summary>
    
      <category term="Java多线程" scheme="http://edgeowner.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Thread" scheme="http://edgeowner.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>日常开发工具集（1）</title>
    <link href="http://edgeowner.com/2017/03/01/DevTools/developing-tools/"/>
    <id>http://edgeowner.com/2017/03/01/DevTools/developing-tools/</id>
    <published>2017-03-01T12:20:25.000Z</published>
    <updated>2017-03-01T13:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;日常工作中只要时方便开发的部分工具的用途及资源会在此文介绍，欢迎广大技术蜀黍添加。</p><h4 id="Java源代码搜索"><a href="#Java源代码搜索" class="headerlink" title="Java源代码搜索"></a>Java源代码搜索</h4><p>&emsp;&emsp;Grepcode(<a href="http://grepcode.com/" target="_blank" rel="noopener">资源地址</a>)是面向Java开发人员的网站，这里可通过Java的<font color="#FF8C69">project</font> 、<font color="#FF8C69">classes</font>等关键字在线查看它对应的源码，知道对应的<font color="#FF8C69">project</font>、<font color="#FF8C69">classes</font>等信息。更方便的是，能提供不同版本的源代码在线查看：<strong>jar包</strong> 、<strong>源码jar包</strong>、<strong>doc下载</strong>。同样，也可以使用xxx-1.1.1.jar类似这样的名字直接找到对应的jar包，从而下载。<br><img src="http://p5vswdxl9.bkt.clouddn.com/Grepcode.jpg" alt="Grepcode"></p><a id="more"></a><h4 id="开源代码以及文档搜索"><a href="#开源代码以及文档搜索" class="headerlink" title="开源代码以及文档搜索"></a>开源代码以及文档搜索</h4><p>&emsp;&emsp;SearchCode(<a href="https://searchcode.com/" target="_blank" rel="noopener">资源地址</a>)是一个源码搜索引擎，目前支持从<strong>Github</strong> 、<strong>Bitbucket</strong>、<strong>Google Code</strong>、<strong>CodePlex</strong>、<strong>SourceForge</strong> 和 <strong>Fedora Project</strong> 平台搜索公开的源码。<br><img src="http://p5vswdxl9.bkt.clouddn.com/searchcode.jpg" alt="Searchcode"></p><h4 id="电子书搜索"><a href="#电子书搜索" class="headerlink" title="电子书搜索"></a>电子书搜索</h4><p>&emsp;&emsp;鸠摩搜书(<a href="https://www.jiumodiary.com/" target="_blank" rel="noopener">资源地址</a>)是一个比较不错的电子书搜索网站。内容也比较全。<br><img src="http://p5vswdxl9.bkt.clouddn.com/jiumodiary.jpg" alt="Jiumodiary"></p><h4 id="网盘资源搜索"><a href="#网盘资源搜索" class="headerlink" title="网盘资源搜索"></a>网盘资源搜索</h4><p>&emsp;&emsp;盘搜(<a href="http://pansou.com" target="_blank" rel="noopener">资源地址</a>)可以通过这个网站搜索百度网盘上面的各种资源。<br><img src="http://p5vswdxl9.bkt.clouddn.com/Pansou.jpg" alt="Pansou"></p><h4 id="无版权图片搜索"><a href="#无版权图片搜索" class="headerlink" title="无版权图片搜索"></a>无版权图片搜索</h4><p>&emsp;&emsp;Unsplash(<a href="https://unsplash.com" target="_blank" rel="noopener">资源地址</a>)是我用过的最好的网站，不需要登录，图片很高请，也比较全。唯一的缺点就是需要英文搜搜<br><img src="http://p5vswdxl9.bkt.clouddn.com/unsplash.jpg" alt="Unsplash"></p><h4 id="在线UML制图"><a href="#在线UML制图" class="headerlink" title="在线UML制图"></a>在线UML制图</h4><p>&emsp;&emsp;ProcessOn(<a href="https://unsplash.com" target="_blank" rel="noopener">资源地址</a>)是一个在线协作绘图平台，为用户提供最强大、易用的作图工具!支持在线创作<strong>流程图</strong> 、<strong>BPMN</strong> 、<strong>UML图</strong> 、<strong>UI界面原型设计</strong>、<strong>iOS界面原型设计</strong>等。<br><img src="http://p5vswdxl9.bkt.clouddn.com/ProcessOn.jpg" alt="ProcessOn"></p><h4 id="Json在线验证及格式化"><a href="#Json在线验证及格式化" class="headerlink" title="Json在线验证及格式化"></a>Json在线验证及格式化</h4><p>&emsp;&emsp;json.cn(<a href="https://www.json.cn/" target="_blank" rel="noopener">资源地址</a>)是比较不错的，不仅支持Json格式的验证及格式化，还可以将Json格式压缩成普通文本等，以及查询Json组件和Json解析相关代码好用功能。<br><img src="http://p5vswdxl9.bkt.clouddn.com/json.cn.jpg" alt="Json.cn"></p><h4 id="json生成java类"><a href="#json生成java类" class="headerlink" title="json生成java类"></a>json生成java类</h4><p>&emsp;&emsp;bejson(<a href="http://www.bejson.com/json2javapojo/" target="_blank" rel="noopener">资源地址</a>Json是目前JavaWeb中数据传输的主要格式，很多时候会有把Json转成Java对象的需求。有时候合作方会提供一个Json的样例，需要我们自己定义Java类，这时候这个工具就派上用场了。<br><img src="http://p5vswdxl9.bkt.clouddn.com/bejson.jpg" alt="bejson"></p><h4 id="SQL自动生成Java代码"><a href="#SQL自动生成Java代码" class="headerlink" title="SQL自动生成Java代码"></a>SQL自动生成Java代码</h4><p>&emsp;&emsp;Json(<a href="http://www.autojcode.com/code/sql2class.jsp#" target="_blank" rel="noopener">资源地址</a>)是目前JavaWeb中数据传输的主要格式，很多时候会有把json转成Java对象的需求。有时候合作方会提供一个json的样例，需要我们自己定义Java类，这时候这个工具就派上用场了。<br><img src="http://p5vswdxl9.bkt.clouddn.com/AutoJcode.jpg" alt="AutoJCode.jpg"></p><h4 id="Maven依赖查询"><a href="#Maven依赖查询" class="headerlink" title="Maven依赖查询"></a>Maven依赖查询</h4><p>&emsp;&emsp;Mvnrepository(<a href="http://mvnrepository.com/" target="_blank" rel="noopener">资源地址</a>)查询开源的Java的jar包版本依赖标签<br><img src="http://p5vswdxl9.bkt.clouddn.com/maven.png" alt="mvnrepository"></p><h4 id="Cron表达式生成"><a href="#Cron表达式生成" class="headerlink" title="Cron表达式生成"></a>Cron表达式生成</h4><p>&emsp;&emsp;Pdtools(<a href="http://www.pdtools.net/tools/becron.jsp" target="_blank" rel="noopener">资源地址</a>)用于配置定时任务的cron表达式。<br><img src="http://p5vswdxl9.bkt.clouddn.com/cron.jpg" alt="cron"></p><h4 id="正则验证"><a href="#正则验证" class="headerlink" title="正则验证"></a>正则验证</h4><p>&emsp;&emsp;(<a href="http://tool.chinaz.com/regex" target="_blank" rel="noopener">资源地址</a>)Java开发对正则表达式肯定不陌生。站长工具提供的正则验证还不错。<br><img src="http://p5vswdxl9.bkt.clouddn.com/regex%281%29.jpg" alt=""></p><h4 id="正则代码生成"><a href="#正则代码生成" class="headerlink" title="正则代码生成"></a>正则代码生成</h4><p>&emsp;&emsp;(<a href="http://tool.chinaz.com/tools/regexgenerate" target="_blank" rel="noopener">资源地址</a>)站长工具提供的正则代码生成。可以一键生成身份证号、邮箱、手机号等验证的正则表达式。<br><img src="http://p5vswdxl9.bkt.clouddn.com/regex2.jpg" alt=""></p><h4 id="时间戳转换"><a href="#时间戳转换" class="headerlink" title="时间戳转换"></a>时间戳转换</h4><p>&emsp;&emsp;(<a href="http://tool.chinaz.com/Tools/unixtime.aspx" target="_blank" rel="noopener">资源地址</a>)时间戳(英语：Timestamp）是指在一连串的资料中加入辨识文字，如时间或日期，用以保障本地端（local）资料更新顺序与远端（remote）一致。<br>Java中很多地方都会用到时间戳，也经常会使用这种转换工具。<br><img src="http://p5vswdxl9.bkt.clouddn.com/timestamp.jpg" alt=""></p><h4 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h4><p>&emsp;&emsp;(<a href="http://tool.chinaz.com/tools/textencrypt.aspx" target="_blank" rel="noopener">资源地址</a>)加密解密也是JavaWeb可能会经常遇到的，有的时候我们需要验证加密算法是否正确，或者要解密等场景，就需要一个在线工具。<br><img src="http://p5vswdxl9.bkt.clouddn.com/md5.jpg" alt=""></p><h4 id="在线调色板"><a href="#在线调色板" class="headerlink" title="在线调色板"></a>在线调色板</h4><p>&emsp;&emsp;(<a href="http://link.fobshanghai.com/rgbcolor.htm" target="_blank" rel="noopener">资源地址</a>)常用MarkDown字体配色使用获取RGB代码例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"微软雅黑"</span> <span class="attr">color</span>=<span class="string">#9900ff</span> <span class="attr">size</span>=<span class="string">2</span>&gt;</span>-Xms1024m -Xmx1024m  -XX:PermSize=512M -XX:MaxPermSize=1024m  -Dfile.encoding=utf-8 <span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="http://p5vswdxl9.bkt.clouddn.com/tiaose.jpg" alt=""></p><h4 id="ASCII-ART生成"><a href="#ASCII-ART生成" class="headerlink" title="ASCII ART生成"></a>ASCII ART生成</h4><p>&emsp;&emsp;ASCII ART生成(<a href="http://patorjk.com/software/taag/" target="_blank" rel="noopener">资源地址</a>)<br><img src="http://p5vswdxl9.bkt.clouddn.com/ASCII%20ART.jpg" alt=""></p><h4 id="常用对照表"><a href="#常用对照表" class="headerlink" title="常用对照表"></a>常用对照表</h4><ol><li><a href="http://tool.oschina.net/commons?type=4" target="_blank" rel="noopener">ASCII对照表</a></li><li><a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="noopener">HTTP状态码</a></li><li><a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">HTTP Content-type</a></li><li><a href="http://tool.oschina.net/commons?type=7" target="_blank" rel="noopener">TCP/UDP常见端口参考</a></li><li><a href="http://tool.oschina.net/commons?type=2" target="_blank" rel="noopener">HTML转义字符</a></li><li><a href="http://tool.oschina.net/commons?type=3" target="_blank" rel="noopener">RGB颜色参考</a></li><li><a href="http://tool.oschina.net/commons?type=8" target="_blank" rel="noopener">网页字体参考</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;日常工作中只要时方便开发的部分工具的用途及资源会在此文介绍，欢迎广大技术蜀黍添加。&lt;/p&gt;
&lt;h4 id=&quot;Java源代码搜索&quot;&gt;&lt;a href=&quot;#Java源代码搜索&quot; class=&quot;headerlink&quot; title=&quot;Java源代码搜索&quot;&gt;&lt;/a&gt;Java源代码搜索&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Grepcode(&lt;a href=&quot;http://grepcode.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;资源地址&lt;/a&gt;)是面向Java开发人员的网站，这里可通过Java的&lt;font color=&quot;#FF8C69&quot;&gt;project&lt;/font&gt; 、&lt;font color=&quot;#FF8C69&quot;&gt;classes&lt;/font&gt;等关键字在线查看它对应的源码，知道对应的&lt;font color=&quot;#FF8C69&quot;&gt;project&lt;/font&gt;、&lt;font color=&quot;#FF8C69&quot;&gt;classes&lt;/font&gt;等信息。更方便的是，能提供不同版本的源代码在线查看：&lt;strong&gt;jar包&lt;/strong&gt; 、&lt;strong&gt;源码jar包&lt;/strong&gt;、&lt;strong&gt;doc下载&lt;/strong&gt;。同样，也可以使用xxx-1.1.1.jar类似这样的名字直接找到对应的jar包，从而下载。&lt;br&gt;&lt;img src=&quot;http://p5vswdxl9.bkt.clouddn.com/Grepcode.jpg&quot; alt=&quot;Grepcode&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具集" scheme="http://edgeowner.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
    
      <category term="tools" scheme="http://edgeowner.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>数据库的锁</title>
    <link href="http://edgeowner.com/2016/11/06/Mysql/dateSourceLock/"/>
    <id>http://edgeowner.com/2016/11/06/Mysql/dateSourceLock/</id>
    <published>2016-11-06T12:20:43.000Z</published>
    <updated>2016-11-06T13:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="http://www.hollischuang.com/archives/909" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;http://www.hollischuang.com/a
      
    
    </summary>
    
      <category term="并发控制相关知识点" scheme="http://edgeowner.com/categories/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="并发控制" scheme="http://edgeowner.com/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
      <category term="锁" scheme="http://edgeowner.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>浅析数据库读现象</title>
    <link href="http://edgeowner.com/2016/11/05/Mysql/dataSourceRead/"/>
    <id>http://edgeowner.com/2016/11/05/Mysql/dataSourceRead/</id>
    <published>2016-11-05T02:20:28.000Z</published>
    <updated>2016-11-05T02:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="http://www.hollischuang.com/archives/900" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;http://www.hollischuang.com/a
      
    
    </summary>
    
      <category term="并发控制相关知识点" scheme="http://edgeowner.com/categories/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="并发控制" scheme="http://edgeowner.com/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
      <category term="锁" scheme="http://edgeowner.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁与悲观锁的实际应用</title>
    <link href="http://edgeowner.com/2016/10/01/Lock/optimistic-pessimistic/"/>
    <id>http://edgeowner.com/2016/10/01/Lock/optimistic-pessimistic/</id>
    <published>2016-10-01T11:20:43.000Z</published>
    <updated>2016-10-01T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h4 id="高并发场景"><a href="#高并发场景" class="headerlink" title="高并发场景"></a>高并发场景</h4><p>&emsp;&emsp;首先假设一个业务场景：数据库中有一条数据，需要获取到当前的值，在当前值的基础上$+10$，然后再更新回去。如果此时有两个线程同时并发处理，第一个线程拿到数据是$10，+10=20$更新回去。第二个线程原本是要在第一个线程的基础上再$+20=40$,结果由于并发访问取到更新前的数据为$10，+20=30$。<br>这就是典型的存在中间状态，导致数据不正确。来看以下的例子：<br>并发所带来的问题，和上文提到的类似，这里有一张price表，表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`price`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`total`</span> <span class="built_in">decimal</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'总值'</span>,</span><br><span class="line">  <span class="string">`front`</span> <span class="built_in">decimal</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'消费前'</span>,</span><br><span class="line">  <span class="string">`end`</span> <span class="built_in">decimal</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'消费后'</span>,</span><br><span class="line">  <span class="string">`add_time`</span> <span class="keyword">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'添加时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="keyword">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>, <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure><a id="more"></a><p>单测例子如下(<a href="">Github代码地址</a>)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就一个主线程，循环100次，每次把front的值减去10，再写入一次流水记录，正常情况是写入的每条记录都会每次减去10。</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleCounsumerTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Price price = priceMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> ron = <span class="number">10</span>;</span><br><span class="line">            price.setFront(price.getFront().subtract(<span class="keyword">new</span> BigDecimal(ron)));</span><br><span class="line">            price.setEnd(price.getEnd().add(<span class="keyword">new</span> BigDecimal(ron)));</span><br><span class="line">            price.setTotal(price.getFront().add(price.getEnd()));</span><br><span class="line"></span><br><span class="line">            priceMapper.updateByPrimaryKey(price);</span><br><span class="line">            price.setId(<span class="keyword">null</span>);</span><br><span class="line">            priceMapper.insertSelective(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行结果如下图：<br><img src="http://p5vswdxl9.bkt.clouddn.com/result1.png" alt="图（1）"><br>可以看到确实是每次都递减10，但是如果是多线程的情况下会是如何呢？（<a href="https://github.com/edgeowner/saber" target="_blank" rel="noopener">代码PriceController</a>）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/price"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PriceApplication priceApplication;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PriceMapper priceMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolConfig config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多线程并发执行Demo ,无锁场景下的更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priceVO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/update"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; updatePrice(<span class="meta">@RequestBody</span> PriceVO priceVO) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (priceVO == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BizException(BizException.NUM_VALIDATION, <span class="string">"priceVO is null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        toUpdatePrice(count);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                config.submit(thread);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> WebUtil.success(<span class="string">"price更新成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BizException ex) &#123;</span><br><span class="line">            log.error(<span class="string">"更新价格失败"</span>, ExceptionUtils.getFullStackTrace(ex));</span><br><span class="line">            <span class="keyword">return</span> WebUtil.error(ex.getErrorMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toUpdatePrice</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        log.info(MessageFormat.format(<span class="string">"thread create start:&#123;0&#125; "</span>, count));</span><br><span class="line">        Price price = priceMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ron = <span class="number">10</span>;</span><br><span class="line">        price.setFront(price.getFront().subtract(<span class="keyword">new</span> BigDecimal(ron)));</span><br><span class="line">        price.setEnd(price.getEnd().add(<span class="keyword">new</span> BigDecimal(ron)));</span><br><span class="line">        priceMapper.updateByPrimaryKey(price);</span><br><span class="line">        price.setId(<span class="keyword">null</span>);</span><br><span class="line">        priceMapper.insertSelective(price);</span><br><span class="line">        log.info(MessageFormat.format(<span class="string">"thread create end:&#123;0&#125; "</span>, count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于线程池的使用今后会仔细探讨。这里就简单理解为有10个线程并发去处理上面单线程的逻辑，来看看结果怎么样？<br><img src="http://p5vswdxl9.bkt.clouddn.com/result2.png" alt="图（2）"></p><p>会看到明显的数据错误，导致错误的原因自然就是有线程读取到了中间状态进行了错误的更新。<br>进而有了以下两种解决方案：<strong><em>悲观锁 </em></strong>和<strong><em>乐观锁 </em></strong>。</p><hr><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>&emsp;&emsp;简单理解下悲观锁：当一个事务锁定了一些数据之后，只有当当前锁提交了事务，释放了锁，其他事务才能获得锁并执行操作。<br>使用方式如下：<br>首先要关闭MySQL的自动提交：set autocommit = 0;<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bigen <span class="comment">--开启事务</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, total, front, <span class="keyword">end</span> <span class="keyword">from</span> price <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> price <span class="keyword">values</span>(?,?,?,?,?)</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> <span class="comment">--提交事务</span></span><br></pre></td></tr></table></figure></p><p>这里使用<strong>select for update</strong>的方式利用数据库开启了悲观锁，锁定了id=1的这条数据(注意：<strong>这里除非是使用了索引会启用行级锁，不然是会使用表锁，将整张表都锁住。</strong>)。之后使用commit提交事务并释放锁，这样下一个线程过来拿到的就是正确的数据。<br>悲观锁一般是用于并发不是很高，并且不允许脏读等情况。但是对数据库资源消耗较大。</p><hr><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>&emsp;&emsp;乐观锁是首先假设数据冲突很少，只有在数据提交修改的时候才进行校验，如果冲突了则不会进行更新。<br>通常的实现方式增加一个version字段，为每一条数据加上版本。每次更新的时候version+1，并且更新时候带上版本号。实现方式如下：<br>新建了一张price_version表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`price_version`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`total`</span> <span class="built_in">decimal</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'总值'</span>,</span><br><span class="line">  <span class="string">`front`</span> <span class="built_in">decimal</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'消费前'</span>,</span><br><span class="line">  <span class="string">`end`</span> <span class="built_in">decimal</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'消费后'</span>,</span><br><span class="line">  <span class="string">`version`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'并发版本控制'</span>,</span><br><span class="line">  <span class="string">`add_time`</span> <span class="keyword">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>  <span class="keyword">COMMENT</span> <span class="string">'添加时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="keyword">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>  <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure></p><p><code>更新数据的SQL</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateByVersion"</span> <span class="attr">parameterType</span>=<span class="string">"com.demo.saber.infrastructure.po.PriceVersion"</span>&gt;</span></span><br><span class="line">        update price_version</span><br><span class="line">        set front = #&#123;front, jdbcType=DECIMAL&#125;,</span><br><span class="line">            version = version + 1</span><br><span class="line">        where id = #&#123;id, jdbcType=INTEGER&#125;</span><br><span class="line">        and version = #&#123;version, jdbcType=INTEGER&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>调用方式</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/priceverion"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceVersionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PriceVersionMapper priceVersionMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolConfig config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多线程并发执行Demo ,乐观锁场景下的更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priceVersionVO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/threadPriceVersion"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; updatePrice(<span class="meta">@RequestBody</span> PriceVersionVO priceVersionVO) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (priceVersionVO == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BizException(BizException.NUM_VALIDATION, <span class="string">"priceVersionVO is null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        PriceVersion priceVersion = priceVersionMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">int</span> ron = <span class="number">10</span>;</span><br><span class="line">                        <span class="comment">//"本次消费=" + ron</span></span><br><span class="line">                        log.info(MessageFormat.format(<span class="string">"当前线程(&#123;0&#125;)本次消费=&#123;1&#125;"</span>, count, ron));</span><br><span class="line">                        priceVersion.setFront(<span class="keyword">new</span> BigDecimal(ron));</span><br><span class="line">                        <span class="keyword">int</span> backflag = priceVersionMapper.updateByVersion(priceVersion);</span><br><span class="line">                        <span class="keyword">if</span> (backflag == <span class="number">0</span>) &#123;</span><br><span class="line">                            log.error(MessageFormat.format(<span class="string">"当前线程(&#123;0&#125;)更新失败"</span>, count));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            log.error(MessageFormat.format(<span class="string">"当前线程(&#123;0&#125;)更新成功"</span>, count));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                config.submit(thread);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> WebUtil.success(<span class="string">"priceVersion更新成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BizException ex) &#123;</span><br><span class="line">            log.error(<span class="string">"更新priceVersion失败"</span>, ExceptionUtils.getFullStackTrace(ex));</span><br><span class="line">            <span class="keyword">return</span> WebUtil.error(ex.getErrorMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>处理逻辑 </strong>：开了三个线程生成了20以内的随机数更新到front字段。调用该接口时日志如下：<br><img src="http://p5vswdxl9.bkt.clouddn.com/result3.jpg" alt="更新日志"><br>可以看到线程1、2、3、4都更新失败了，线程0更新成功了。</p><p>乐观锁在实际应用相对较多，它可以提供更好的并发访问，并且数据库开销较少，但是有可能存在脏读的情况。</p><hr><h4 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h4><p><a href="https://github.com/edgeowner/saber" target="_blank" rel="noopener">edgeowner</a></p><h4 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h4><p><a href="https://juejin.im/post/5962e64c6fb9a06ba14b9cd9" target="_blank" rel="noopener">SSM (十五) 乐观锁与悲观锁的实际应用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;高并发场景&quot;&gt;&lt;a href=&quot;#高并发场景&quot; class=&quot;headerlink&quot; title=&quot;高并发场景&quot;&gt;&lt;/a&gt;高并发场景&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;首先假设一个业务场景：数据库中有一条数据，需要获取到当前的值，在当前值的基础上$+10$，然后再更新回去。如果此时有两个线程同时并发处理，第一个线程拿到数据是$10，+10=20$更新回去。第二个线程原本是要在第一个线程的基础上再$+20=40$,结果由于并发访问取到更新前的数据为$10，+20=30$。&lt;br&gt;这就是典型的存在中间状态，导致数据不正确。来看以下的例子：&lt;br&gt;并发所带来的问题，和上文提到的类似，这里有一张price表，表结构如下：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`price`&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; AUTO_INCREMENT &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;主键&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`total`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;decimal&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;0.00&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;总值&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`front`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;decimal&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;0.00&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;消费前&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`end`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;decimal&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;0.00&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;消费后&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`add_time`&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;timestamp&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;添加时间&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`update_time`&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;timestamp&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;更新时间&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) &lt;span class=&quot;keyword&quot;&gt;ENGINE&lt;/span&gt;=&lt;span class=&quot;keyword&quot;&gt;InnoDB&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;CHARSET&lt;/span&gt;=utf8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="并发控制相关知识点" scheme="http://edgeowner.com/categories/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="并发控制" scheme="http://edgeowner.com/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
      <category term="锁" scheme="http://edgeowner.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁和悲观锁(OCC和PCC)</title>
    <link href="http://edgeowner.com/2016/10/01/SortAlogrithms/optimistic-pessimistic-locking/"/>
    <id>http://edgeowner.com/2016/10/01/SortAlogrithms/optimistic-pessimistic-locking/</id>
    <published>2016-10-01T11:20:43.000Z</published>
    <updated>2016-10-01T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&emsp;&emsp;本文在介乐观锁和悲观锁之前请先了解<a href="http://edgeowner.com/2016/10/01/tranaction/">事务相关知识点</a>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。<br>&emsp;&emsp;无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。<br>&emsp;&emsp;针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。</p><hr><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h4 id="乐观锁（Optimistic-Concurrency-Control，OCC）："><a href="#乐观锁（Optimistic-Concurrency-Control，OCC）：" class="headerlink" title="乐观锁（Optimistic Concurrency Control，OCC）："></a>乐观锁（Optimistic Concurrency Control，OCC）：</h4><h5 id="乐观锁的定义："><a href="#乐观锁的定义：" class="headerlink" title="乐观锁的定义："></a>乐观锁的定义：</h5><ul><li>1.在关系数据库管理系统里，乐观锁指的是一种并发控制的方法，又名“乐观锁”(Optimistic Concurrency Control)，缩写“OCC”，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</li><li>2.乐观锁(Optimistic Locking)相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</li><li>3.相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</li></ul><h5 id="乐观锁的流程："><a href="#乐观锁的流程：" class="headerlink" title="乐观锁的流程："></a>乐观锁的流程：</h5><ul><li>1.数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。</li><li>2.对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较和替换这两个动作作为一个原子操作尝试去修改内存中的变量，若失败则表示发生冲突，那么就应该有相应的重试逻辑。</li></ul><h5 id="悲观锁Demo演示："><a href="#悲观锁Demo演示：" class="headerlink" title="悲观锁Demo演示："></a>悲观锁Demo演示：</h5><ul><li><p>1.实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。使用版本号实现乐观锁：使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行$+1$操作。并判断当前版本号是不是该数据的最新的版本号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#Demo 1.0</span><br><span class="line">1.查询出商品信息</span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">status</span>,<span class="keyword">status</span>,<span class="keyword">version</span>) <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span>=#&#123;<span class="keyword">id</span>&#125;</span><br><span class="line"><span class="number">2.</span>根据商品信息生成订单</span><br><span class="line"><span class="number">3.</span>修改商品<span class="keyword">status</span>为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> t_goods </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span>=#&#123;<span class="keyword">id</span>&#125; <span class="keyword">and</span> <span class="keyword">version</span>=#&#123;<span class="keyword">version</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>2.对于并发间操作产生的线程安全问题持悲状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，直接上了锁就操作资源</li></ul></li></ul><h5 id="悲观锁的优点和不足："><a href="#悲观锁的优点和不足：" class="headerlink" title="悲观锁的优点和不足："></a>悲观锁的优点和不足：</h5><p>&emsp;&emsp;乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p><hr><h4 id="悲观锁（Pessimistic-Concurrency-Control，PCC）："><a href="#悲观锁（Pessimistic-Concurrency-Control，PCC）：" class="headerlink" title="悲观锁（Pessimistic Concurrency Control，PCC）："></a>悲观锁（Pessimistic Concurrency Control，PCC）：</h4><h5 id="悲观锁的定义："><a href="#悲观锁的定义：" class="headerlink" title="悲观锁的定义："></a>悲观锁的定义：</h5><ul><li>1.悲观锁指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）；</li><li>2.关系型数据库里，<strong>悲观并发控制</strong>是一种并发控制的方法。它可以阻止一个事物以影响其他用户的方式来修改数据。如果一个事物执行的操作都某行数据应用了锁，那只有当这个事物把锁释放，其他事物才能执行与该锁冲突的操作。</li></ul><h5 id="悲观锁的流程："><a href="#悲观锁的流程：" class="headerlink" title="悲观锁的流程："></a>悲观锁的流程：</h5><ul><li>1.悲观锁的流程：在对任意记录进行修改前，先尝试为该记录加上<a href="http://www.hollischuang.com/archives/923" target="_blank" rel="noopener">排他锁(exclusive locking)</a>，如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁，期间若有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li></ul><h5 id="悲观锁Demo演示：-1"><a href="#悲观锁Demo演示：-1" class="headerlink" title="悲观锁Demo演示："></a>悲观锁Demo演示：</h5><ul><li>1.Mysql InnoDB使用悲观锁：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#Demo 1.0</span><br><span class="line">//0.开始事务</span><br><span class="line"><span class="keyword">begin</span>;/<span class="keyword">begin</span> <span class="keyword">work</span>;/<span class="keyword">start</span> <span class="keyword">transaction</span>; (三者选一就可以)</span><br><span class="line">//1.查询出商品信息</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">//2.根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_orders (<span class="keyword">id</span>,goods_id) <span class="keyword">values</span> (<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line">//3.修改商品status为2</span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>;</span><br><span class="line">//4.提交事务</span><br><span class="line"><span class="keyword">commit</span>;/<span class="keyword">commit</span> <span class="keyword">work</span>;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;上面的查询语句中，我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。<br>  <strong><em>使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意 </em></strong>。<br>  简单理解下悲观锁：当一个事务锁定了一些数据之后，只有当当前锁提交了事务，释放了锁，其他事务才能获得锁并执行操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事物的成本环境中。</p><ul><li>2.下面另外一个简单Demo使用方式如下：<br>   首先要关闭MySQL的自动提交：set autocommit = 0;     <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Demo 2.0</span><br><span class="line"><span class="keyword">begin</span> <span class="comment">--开启事务</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, total, front, <span class="keyword">end</span> <span class="keyword">from</span> price <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> price <span class="keyword">values</span>(?,?,?,?,?)</span><br><span class="line"><span class="keyword">commit</span> <span class="comment">--提交事务</span></span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;这里使用<strong>select for update的方式</strong>利用数据库开启了悲观锁，锁定了id=1的这条数据(<strong><em>注意:这里除非是使用了索引会启用行级锁，不然是会使用表锁，将整张表都锁住。 </em></strong>)。之后使用commit提交事务并释放锁，这样下一个线程过来拿到的就是正确的数据。<br>悲观锁一般是用于并发不是很高，并且不允许脏读等情况。但是对数据库资源消耗较大。</p><h5 id="悲观锁的优点和不足：-1"><a href="#悲观锁的优点和不足：-1" class="headerlink" title="悲观锁的优点和不足："></a>悲观锁的优点和不足：</h5><p>&emsp;&emsp;悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数.</p><hr><h4 id="相关技术参考："><a href="#相关技术参考：" class="headerlink" title="相关技术参考："></a>相关技术参考：</h4><ol><li><a href="https://juejin.im/post/5962e64c6fb9a06ba14b9cd9" target="_blank" rel="noopener">乐观锁与悲观锁的实际应用</a>(<strong>推荐此文</strong>)</li><li><a href="https://segmentfault.com/a/1190000008935924" target="_blank" rel="noopener">MySQL乐观锁在分布式场景下的实践</a>(<strong>推荐此文</strong>)</li><li><a href="http://www.digpage.com/lock.html" target="_blank" rel="noopener">乐观锁与悲观锁</a></li><li><a href="http://www.hollischuang.com/archives/934" target="_blank" rel="noopener">深入理解乐观锁与悲观锁</a></li><li><a href="http://www.importnew.com/21037.html" target="_blank" rel="noopener">深入理解乐观锁与悲观锁</a></li><li><a href="https://www.cnblogs.com/deliver/p/5730616.html" target="_blank" rel="noopener">mysql的锁—行锁，表锁，乐观锁，悲观锁</a></li><li><a href="http://www.hollischuang.com/archives/909" target="_blank" rel="noopener">数据库的锁机制</a></li></ol><h4 id="本文代码Demo："><a href="#本文代码Demo：" class="headerlink" title="本文代码Demo："></a>本文代码Demo：</h4><p>Github地址：<a href="git@github.com:edgeowner/saber.git">参见Price相关代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&amp;emsp;&amp;emsp;本文在介乐观锁和悲观锁之前请先了解&lt;a href=&quot;
      
    
    </summary>
    
      <category term="并发控制相关知识点" scheme="http://edgeowner.com/categories/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="并发控制" scheme="http://edgeowner.com/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
      <category term="锁" scheme="http://edgeowner.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>事务知识点</title>
    <link href="http://edgeowner.com/2016/10/01/Transaction/transaction/"/>
    <id>http://edgeowner.com/2016/10/01/Transaction/transaction/</id>
    <published>2016-10-01T11:20:43.000Z</published>
    <updated>2016-10-01T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>&emsp;&emsp;本文主要介绍事务的相关知识点，同时也为后续讲解乐观锁和悲观锁作铺垫，先对以下事务相关的知识点：<code>ACID</code>、<code>事物的常见问题</code>以及<code>事务的隔离级别</code>先做介绍，至于<code>锁</code>后续会有专题详细介绍。<br>事务就是一组原子性的sql，或者一个独立的工作单元，事务可以就Mysql引擎来说的话就是要么全部执行这一组sql语句（CURD组合），要么全部都不执行（比如其中一条语句失败会导致这一组语句全部失败）。<br>事务是并发控制的单元，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位，说白了就是为了保证系统始终处于一个完整且正确的状态。</p><a id="more"></a><hr><h4 id="事务特性：ACID"><a href="#事务特性：ACID" class="headerlink" title="事务特性：ACID"></a>事务特性：ACID</h4><p>事务的ACID特性：</p><h5 id="A：Atomiciy-原子性-："><a href="#A：Atomiciy-原子性-：" class="headerlink" title="A：Atomiciy(原子性)："></a>A：Atomiciy(原子性)：</h5><p>一个事物必须保证其中的操作要么全部执行，要么全部回滚，不可能存在只执行了一部分这种情况出现。简单说就是事务是一个不可分隔的工作单位，事务中的操作要么都发生，要么都不发生；</p><p>事务包含的全部操作是一个不可分割的整体，要么全部执行，要么全部都不执行。</p><h5 id="C：Consistency-一致性-："><a href="#C：Consistency-一致性-：" class="headerlink" title="C：Consistency(一致性)："></a>C：Consistency(一致性)：</h5><p>数据必须保证从一种一致性的状态转换为另一种一致性状态。也就是事务开始到结束的时间段内，事务前后数据的完整性必须保证一致；  </p><p>例如：事务之前A,B两个账户的总和是10万(A:4W,B:6W),现在A转账B2万(A:2W,B:8W),A,B账户总和依旧应该是10万，如果不是10万的话，则事务前后对于账户总和这种资源是不一致的。</p><h5 id="I：Isolation-隔离性-："><a href="#I：Isolation-隔离性-：" class="headerlink" title="I：Isolation(隔离性)："></a>I：Isolation(隔离性)：</h5><p>在一个事物未执行完毕时，通常会保证其他Session无法看到这个事务的执行结果。也就是说多个用户并发访问数据库时，一个用户的事物不能被其他用户的事物所干扰，多个并发事务之间数据要相互隔离。数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的”独立”环境执行；</p><p>主要规定了各个事务之间相互影响的程度，主要用于规定多个事务访问同一数据资源，各个事务对该数据资源访问的行为。</p><h5 id="D：Durability-持久性-："><a href="#D：Durability-持久性-：" class="headerlink" title="D：Durability(持久性)："></a>D：Durability(持久性)：</h5><p>事务一旦commit，则数据就会保存下来，即使提交完之后系统崩溃，数据也不会丢失。</p><p>事务一旦完成，要将数据所做的变更记录下来(冗余存储或多数据网络备份)。</p><hr><h4 id="事务常见问题"><a href="#事务常见问题" class="headerlink" title="事务常见问题"></a>事务常见问题</h4><h5 id="更新丢失-Lost-Update-："><a href="#更新丢失-Lost-Update-：" class="headerlink" title="更新丢失(Lost Update)："></a><code>更新丢失(Lost Update)</code>：</h5><ol><li>场景：假定两个事物有$A$和$B$，事务$A$和事物$B$同时获得相同的数据，然后在各自的事物中修改数据M，事先$A$先提交事物，数据M假如为$M+$，事务$B$后提交事物，数据$M$变成了$M++$，最终结果变成$M++$，覆盖了事物$A$的更新。  </li><li>原因：当多个事务选择同一行操作，并且都是基于最初选定的值，由于每个事务都不知道其他事务的存在，就会发生更新覆盖的问题。类比Github提交冲突。  </li><li>例子：   </li></ol><div class="table-container"><table><thead><tr><th>事物$A$</th><th>事物$B$</th></tr></thead><tbody><tr><td>读取 $X=100$</td><td>读取 $X=100$</td></tr><tr><td>写入 $X=X+100$</td><td></td></tr><tr><td>事物结束 $X = 200$</td><td></td></tr><tr><td></td><td>写入 $X =X+100$</td></tr><tr><td></td><td>事物结束 $X=300$(事物A的数据更新丢失)</td></tr></tbody></table></div><h5 id="脏读-Dirty-Reads-："><a href="#脏读-Dirty-Reads-：" class="headerlink" title="脏读(Dirty Reads)："></a><code>脏读(Dirty Reads)</code>：</h5><ol><li>场景：<strong>允许事物B可以读到事物A修改而未提交的数据</strong>，<strong>可能</strong>会造成脏读（脏读本质就是无效数据，只有当事物$A$回滚，那么事物B读到的数据才为无效的，所以这里只是<strong>可能</strong>造成脏读，当事物$A$不回滚的时候，事物$B$读到的数据就不为脏数据，也就是有效的数据，脏数据会导致以后的操作都会发生错误，一定要避免，不能凭借侥幸，事物$A$不能百分之百保证不回滚，所以<strong>这种隔离级别很少用于实际应用</strong>，并且它的性能也不比其他借笔好）。</li><li>原因：事物B读取了事物$A$已经修改但尚未提交的数据。若事物$A$回滚数据，事物$A$的数据存在不一致性的问题。</li><li>例子：</li></ol><div class="table-container"><table><thead><tr><th>事物$A$</th><th>事物$B$</th></tr></thead><tbody><tr><td>写入 $X=X+100(x=200)$</td><td></td></tr><tr><td></td><td>读取 $X=200$(无效数据，脏读)</td></tr><tr><td>事务回滚 $X=100$</td><td></td></tr><tr><td>事务结束 $X=100$</td><td></td></tr><tr><td></td><td>事务结束</td></tr></tbody></table></div><h5 id="不可重复读-Non-Repeatable-Reads-："><a href="#不可重复读-Non-Repeatable-Reads-：" class="headerlink" title="不可重复读(Non-Repeatable Reads)："></a><code>不可重复读(Non-Repeatable Reads)</code>：</h5><ol><li>场景：不可重复读是指在一个事务范围中$2$次或者多次查询同一数据$M$返回了不同的数据，例如：事务$B$读取某一数据，事务$A$修改了该数据$M$并且提交，事务$B$又读取该数据$M$(可能是再次校验)，在同一个事务$B$中，读取同一个数据$M$的结果集不同。</li><li>原因：事物$B$第一次读取最初数据，第二次读取事物A已经提交的修改或删除数据。导致两次读取数据不一致。不符合事物的隔离性。</li><li>例子：</li></ol><div class="table-container"><table><thead><tr><th>事物$A$</th><th>事物$B$</th></tr></thead><tbody><tr><td>读取 $X=100$</td><td>读取 $X=100$</td></tr><tr><td>写入 $X=X+100$</td><td>读取 $X=100$</td></tr><tr><td>事务结束，$X=200$</td><td></td></tr><tr><td></td><td>读取 $X=200$(在一个事务B中读X的值发生了变化)</td></tr><tr><td></td><td>事物结束</td></tr></tbody></table></div><h5 id="幻读-Phantom-Reads-："><a href="#幻读-Phantom-Reads-：" class="headerlink" title="幻读(Phantom Reads)："></a><code>幻读(Phantom Reads)</code>：</h5><ol><li>当用户读取某一个范围的数据行时，另一个事物又在该范围内查询了新行，当用户再读取该范围的数据行时，会发现会有新的“幻影行”，例如：事物$B$读到某一个数据$M$，事物$A$对数据$M$增加了一行并提交，事物$B$又读数据$M$，发生多出了一行造成的结果不一致(如果行数相同，则是不可重复读)。   </li><li>原因：事物$B$根据相同的条件第二次查询到事物$A$提交的新增数据，两次数据结果集不一致。不符合事物的隔离性。</li><li>例子：在事物$B$里，同一个数据集$M$，读到的条数不一致(新增，删除)。</li></ol><div class="table-container"><table><thead><tr><th>事务$A$</th><th>事务$B$</th></tr></thead><tbody><tr><td></td><td>读取数据集$M$(3行)</td></tr><tr><td>在数据集$M$插入一行(4行)</td><td></td></tr><tr><td>事务结束</td><td></td></tr><tr><td></td><td>读取数据$M$(4行)</td></tr><tr><td></td><td>事务结束</td></tr></tbody></table></div><hr><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><p>数据库的事物隔离越严格，并发副作用越小，但付出的代价也就越大。因为事务隔离实质上是将事务在一定程度上“串行”进行，这显然与“并发”是矛盾的。实际业务中处理的话，根据自己的业务逻辑，权衡能接受的最大副作用，从而平衡了<strong><em>“隔离” </em></strong>和<strong><em>“并发” </em></strong>的问题。Mysql默认隔离级别是可重复读的。<br>事务的隔离级别通常有四种（RU, RC, RR，Serializable）：</p><div class="table-container"><table><thead><tr><th>隔离级别</th><th>读数据一致性</th><th>脏读可能性</th><th>不可重复读可能性</th><th>幻读可能性</th><th>加锁读</th></tr></thead><tbody><tr><td>未提交读(Read uncommitted)</td><td>最低级别</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>已提交读(Read committed)</td><td>语句级别</td><td>N</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>可重复读(Repeatable read)</td><td>事务级别</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>可序列化(Serializable)</td><td>最高级别，事务级别</td><td>N</td><td>N</td><td>N</td><td>Y</td></tr></tbody></table></div><hr><h4 id="MySql常用命令"><a href="#MySql常用命令" class="headerlink" title="MySql常用命令"></a>MySql常用命令</h4><h5 id="查询隔离级别"><a href="#查询隔离级别" class="headerlink" title="查询隔离级别"></a>查询隔离级别</h5><p>select @@tx_isolation;</p><h5 id="设置手动提交"><a href="#设置手动提交" class="headerlink" title="设置手动提交"></a>设置手动提交</h5><p>set autocommit=0 ;</p><h5 id="查看当前事务自动提交模式"><a href="#查看当前事务自动提交模式" class="headerlink" title="查看当前事务自动提交模式"></a>查看当前事务自动提交模式</h5><p>select @@autocommit;</p><h5 id="设置隔离级别"><a href="#设置隔离级别" class="headerlink" title="设置隔离级别"></a>设置隔离级别</h5><p>set tx_isolation = ‘READ-COMMITTED’;</p><h5 id="查询表的状态"><a href="#查询表的状态" class="headerlink" title="查询表的状态"></a>查询表的状态</h5><p>show table status like ‘test1’;</p><h5 id="修改表的存储引擎"><a href="#修改表的存储引擎" class="headerlink" title="修改表的存储引擎"></a>修改表的存储引擎</h5><p>alter table test1 engine = INNODB</p><h5 id="查看是否开启日志"><a href="#查看是否开启日志" class="headerlink" title="查看是否开启日志"></a>查看是否开启日志</h5><p>show variables like ‘log_bin’;</p><h5 id="查看日志状态"><a href="#查看日志状态" class="headerlink" title="查看日志状态"></a>查看日志状态</h5><p>show master status;</p><hr><h4 id="相关技术参考："><a href="#相关技术参考：" class="headerlink" title="相关技术参考："></a>相关技术参考：</h4><p><a href="https://segmentfault.com/a/1190000004437223" target="_blank" rel="noopener">深入浅出事务（1）</a><br><a href="https://segmentfault.com/a/1190000004437275" target="_blank" rel="noopener">深入浅出事务（2）</a><br><a href="https://segmentfault.com/a/1190000004469395" target="_blank" rel="noopener">深入浅出事务（3）</a><br><a href="https://segmentfault.com/a/1190000012773157" target="_blank" rel="noopener">MySQL表锁和行锁机制</a><br><a href="https://juejin.im/post/5ab5e44a6fb9a028c97a013d" target="_blank" rel="noopener">Mysql之锁与事务</a><br><a href="https://segmentfault.com/a/1190000013122242" target="_blank" rel="noopener">数据库 - 事务管理（ACID）、隔离级别、事务传播行为</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;本文主要介绍事务的相关知识点，同时也为后续讲解乐观锁和悲观锁作铺垫，先对以下事务相关的知识点：&lt;code&gt;ACID&lt;/code&gt;、&lt;code&gt;事物的常见问题&lt;/code&gt;以及&lt;code&gt;事务的隔离级别&lt;/code&gt;先做介绍，至于&lt;code&gt;锁&lt;/code&gt;后续会有专题详细介绍。&lt;br&gt;事务就是一组原子性的sql，或者一个独立的工作单元，事务可以就Mysql引擎来说的话就是要么全部执行这一组sql语句（CURD组合），要么全部都不执行（比如其中一条语句失败会导致这一组语句全部失败）。&lt;br&gt;事务是并发控制的单元，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位，说白了就是为了保证系统始终处于一个完整且正确的状态。&lt;/p&gt;
    
    </summary>
    
      <category term="并发控制相关知识点" scheme="http://edgeowner.com/categories/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="事务" scheme="http://edgeowner.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题目集锦 (1)</title>
    <link href="http://edgeowner.com/2016/06/01/InterviewCase/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E9%9B%86%E9%94%A6/"/>
    <id>http://edgeowner.com/2016/06/01/InterviewCase/Java面试题目集锦/</id>
    <published>2016-06-01T12:21:37.000Z</published>
    <updated>2018-03-14T02:35:47.142Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;
      
    
    </summary>
    
      <category term="Java面试题目汇总" scheme="http://edgeowner.com/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    
    
      <category term="Java" scheme="http://edgeowner.com/tags/Java/"/>
    
      <category term="面试题" scheme="http://edgeowner.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Chapter(1)</title>
    <link href="http://edgeowner.com/2016/05/01/JavaMultiThreadBook/MultiThreadChapter1/"/>
    <id>http://edgeowner.com/2016/05/01/JavaMultiThreadBook/MultiThreadChapter1/</id>
    <published>2016-05-01T04:20:43.000Z</published>
    <updated>2016-05-01T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="Thread类中start-方法和run-方法的区别"><a href="#Thread类中start-方法和run-方法的区别" class="headerlink" title="Thread类中start()方法和run()方法的区别"></a>Thread类中start()方法和run()方法的区别</h3><ol><li>Thread.java类中的start()方法通知“线程规划器”，此线程已经准备就绪，等待调用线程对象的run()方法。这个过程其实就是让系统安排一个时间来调用Thread中的run()方法，也就是使线程得到运行，启动线程，具有异步执行的效果。</li><li>如果代码调用thread.run()方法就不是异步执行，而是同步，那么此线程对象并不交给“线程规划器”来进行处理，而是由main()主线程来调用run()方法，也就是必须等run()方法中的代码执行完后才可以执行后面的代码。</li><li>(<a href="https://github.com/edgeowner/JavaMulti-threadProgramming" target="_blank" rel="noopener"><font color="#ff6600">代码Demo地址</font></a>)：参见com.multithread.demo.chapter1.ThreadShareDemo目录下代码</li></ol><a id="more"></a><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Thread类中start-方法和run-方法的区别&quot;&gt;&lt;a href=&quot;#Thread类中start-方法和run-方法的区别&quot; class=&quot;headerlink&quot; title=&quot;Thread类中start()方法和run()方法的区别&quot;&gt;&lt;/a&gt;Thread类中start()方法和run()方法的区别&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Thread.java类中的start()方法通知“线程规划器”，此线程已经准备就绪，等待调用线程对象的run()方法。这个过程其实就是让系统安排一个时间来调用Thread中的run()方法，也就是使线程得到运行，启动线程，具有异步执行的效果。&lt;/li&gt;
&lt;li&gt;如果代码调用thread.run()方法就不是异步执行，而是同步，那么此线程对象并不交给“线程规划器”来进行处理，而是由main()主线程来调用run()方法，也就是必须等run()方法中的代码执行完后才可以执行后面的代码。&lt;/li&gt;
&lt;li&gt;(&lt;a href=&quot;https://github.com/edgeowner/JavaMulti-threadProgramming&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font color=&quot;#ff6600&quot;&gt;代码Demo地址&lt;/font&gt;&lt;/a&gt;)：参见com.multithread.demo.chapter1.ThreadShareDemo目录下代码&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java Multi-thread Programming书籍" scheme="http://edgeowner.com/categories/Java-Multi-thread-Programming%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="多线程" scheme="http://edgeowner.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(4)</title>
    <link href="http://edgeowner.com/2016/04/27/JVM/jvm-introduce/"/>
    <id>http://edgeowner.com/2016/04/27/JVM/jvm-introduce/</id>
    <published>2016-04-27T09:00:00.000Z</published>
    <updated>2016-04-27T11:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>&emsp;&emsp;JVM内存结构主要有三大块：<strong><em>堆内存</em></strong> 、<strong><em>方法法区</em></strong> 和 <strong><em>栈</em></strong>。<br>&emsp;&emsp;<strong><em>堆内存</em></strong> 是JVM中最大的一块由 <strong>年轻代</strong>和 <strong>老年代</strong> 组成，而年轻代内存又被分为三部分， <strong>Eden空间</strong> 、<strong>From Survivo空间</strong> 、<strong>To Survivor空间</strong> ，默认情况下年轻代按照$8:1:1$的比例来分配；<font color="#FF3030">方法区存储类信息、常量、静态变量等数据，是线程共享的区域</font> ，为与<strong>Java堆</strong>区分，方法区还有一个别名NonHeap(非堆)；栈又分为 <strong>Java虚拟机栈</strong> 和 <strong>本地方法栈</strong> 主要用于方法的执行。<br>&emsp;&emsp;<font color="#FF0000">JAVA的JVM的内存可分为3个区</font>： <strong>堆(Heap)</strong>、 <strong>栈(Stack)</strong>  、 <strong>方法区(Method Area)</strong> 。实际IDEA开发Tomcat启动项配置示例：  </p><blockquote><font face="微软雅黑" color="#9900ff" size="2">-Xms1024m -Xmx1024m  -XX:PermSize=512M -XX:MaxPermSize=1024m  -Dfile.encoding=utf-8 </font>   </blockquote><a id="more"></a><hr><h3 id="Java堆-Java-Heap"><a href="#Java堆-Java-Heap" class="headerlink" title="Java堆(Java Heap)"></a>Java堆(Java Heap)</h3><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>Java堆可通过参数 <font color="#EE7942">-Xms</font> 和  <font color="#EE7942">-Xmx</font>设置；</p><h4 id="存储内容"><a href="#存储内容" class="headerlink" title="存储内容"></a>存储内容</h4><p>Java堆是存放对象的实例，几乎所有的<font color="#EE6A50">对象实例</font>和<font color="#EE6A50">数组</font>都存储于此区域，是被所有线程共享，是JVM虚拟机管理的内存中最大的一块，在虚拟机启动时创建；</p><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>为了便于更好的回收和分配内存，堆可细分为：<strong>新生代</strong>和<strong>老年代</strong>，<strong>新生代</strong> 在细致一些就是<font color="#EE3B3B">Eden空间、From Survivor空间、To Survivor区</font>。</p><ol><li>新生代：包括Eden区、From Survivor区、To Survivor区，系统默认大小 $Eden:Survivor= 8:1$</li><li>老年代：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中。因此可认为老年代中存放的都是一些生命周期较长的对象</li></ol><p>Survivor空间等Java堆可以处理在物理内存不连续的空间，只要逻辑上是连续即可。</p><hr><h3 id="Java虚拟机栈-Stack"><a href="#Java虚拟机栈-Stack" class="headerlink" title="Java虚拟机栈(Stack)"></a>Java虚拟机栈(Stack)</h3><h4 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h4><p>可通过参数 栈帧是方法运行期的基础数据结构栈容量可由-Xss设置；</p><h4 id="存储内容-1"><a href="#存储内容-1" class="headerlink" title="存储内容"></a>存储内容</h4><p>Java虚拟机栈是线程私有的，它的生命周期与线程相同</p><ol><li>每个方法被调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中从入栈到出栈的过程</li><li><p>虚拟机栈是执行Java方法的内存模型(也就是字节码)服务：**每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p><ol><li><font color="#FF0000">局部变量表</font>：32位变量槽，存放了编译期可知的 <strong>各种基本数据类型</strong>、<strong>对象引用</strong>、<strong>returnAddress类型</strong></li><li><font color="#FF0000">操作数栈</font>：基于栈的执行引擎，虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。</li><li><font color="#FF0000">动态链接</font>：<strong>每个栈帧都包含一个指向运行时常量池(方法区的一部分)中该栈帧所属方法的引用</strong>。持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为<strong>静态解析</strong>。另一部分将在每次的运行期间转化为直接应用，这部分称为<strong>动态链接</strong></li><li><font color="#FF0000">方法出口</font>：返回方法被调用的位置，恢复上层方法的局部变量和操作数栈，如果无返回值，则把它压入调用者的操作数栈。</li></ol></li><li><p><strong>局部变量表所需的内存空间在编译期间完成分配</strong>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的。</p></li><li><strong>在方法运行期间不会改变局部变量表的大小。主要存放了编译之后可知的各种基本数据类型、对象引用。</strong><font color="#33ccff">（<a href="http://www.runoob.com/java/java-basic-datatypes.html" target="_blank" rel="noopener">reference类型、returnAddress类型</a>）</font></li></ol><hr><h3 id="本地方法栈-Local-Method-Stack"><a href="#本地方法栈-Local-Method-Stack" class="headerlink" title="本地方法栈(Local Method Stack)"></a>本地方法栈(Local Method Stack)</h3><h4 id="参数设置-2"><a href="#参数设置-2" class="headerlink" title="参数设置"></a>参数设置</h4><p>可通过参数 栈容量可由-Xss设置。</p><h4 id="存储内容-2"><a href="#存储内容-2" class="headerlink" title="存储内容"></a>存储内容</h4><ol><li>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务。</li><li>本地方法栈则是为虚拟机使用到的Native方法服务。有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</li></ol><hr><h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h3><h4 id="参数设置-3"><a href="#参数设置-3" class="headerlink" title="参数设置"></a>参数设置</h4><p>可通过参数-XX:MaxPermSize设置</p><h4 id="存储内容-3"><a href="#存储内容-3" class="headerlink" title="存储内容"></a>存储内容</h4><ol><li><strong>线程共享内存区域，用于储存已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码，方法区也称持久代（Permanent Generation）</strong>。</li><li>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做<font color="#DC143C">Non-Heap（非堆）</font>，目的应该是与Java堆区分开来。</li><li>如何实现方法区，属于虚拟机的实现细节，不受虚拟机规范的约束。</li><li>方法区主要存放java类定义信息，与垃圾回收关系不大，方法区可以选择不实现垃圾回收，<font color="#EE2C2C">但不是没有垃圾回收</font>。</li><li><strong>方法区域的内存回收目标主要针对常量池的回收和对类型的卸载。</strong></li><li><strong><font color="#EE2C2C">运行时常量池</font>，也是方法区的一部分，虚拟机加载Class后把常量池中的数据放入运行时常量池</strong>。</li></ol><hr><h3 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池(Runtime Constant Pool)"></a>运行时常量池(Runtime Constant Pool)</h3><h4 id="参数设置-4"><a href="#参数设置-4" class="headerlink" title="参数设置"></a>参数设置</h4><p>可通过参数-XX:PermSize和-XX:MaxPermSize设置</p><h4 id="存储内容-4"><a href="#存储内容-4" class="headerlink" title="存储内容"></a>存储内容</h4><ol><li><font color="#EE4000">常量池(Constant Pool)</font>：<strong>常量池数据编辑之后被确定，是Class文件中的一部分。存储了类、方法、接口等中的常量，也包括字符串常量。</strong></li><li><font color="#EE4000">字符串池/字符串常量池(String  Pool/ String Constant Pool)</font>：是常量池中的一部分，存储编译期类中产生的<font color="#EE0000">字符串类型数据。</font></li><li><font color="#EE4000">运行时常量池(Runtime Constant Pool)</font>：**方法区的一部分，所有线程共享。虚拟机加载Class后把常量池中的数据放入到运行时常量池**。<font color="#EE3B3B">常量池</font>：可以理解为Class文件中的资源仓库，它是Class文件结构中与其他项目资源关联最多的数据类型。 1. 常量池中主要存放两大类常量：<font color="#EE4000">字面量</font>(Literal)和<font color="#EE4000">符号引用</font>(Symbolic Reference)。 2. **字面量**：文本字符串、声明为final的常量值等。 3. **符号引用**：<font color="#EE4000">类和接口的完全限定名</font>(Fully Qualified Name)、<font color="#EE4000">字段的名称</font>和<font color="#EE4000">描述符</font>(Descriptor)、<font color="#EE4000">方法的名称</font>和<font color="#EE4000">描述符号</font></li></ol><hr><h3 id="直接内存-Direct-Memory"><a href="#直接内存-Direct-Memory" class="headerlink" title="直接内存(Direct Memory)"></a>直接内存(Direct Memory)</h3><h4 id="参数设置-5"><a href="#参数设置-5" class="headerlink" title="参数设置"></a>参数设置</h4><p>可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值（-Xmx指定）一样。</p><h4 id="存储内容-5"><a href="#存储内容-5" class="headerlink" title="存储内容"></a>存储内容</h4><p><strong>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</strong></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5aae4e8f6fb9a028e52d9e8c" target="_blank" rel="noopener">50个多线程面试题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存结构&quot;&gt;&lt;a href=&quot;#JVM内存结构&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构&quot;&gt;&lt;/a&gt;JVM内存结构&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;JVM内存结构主要有三大块：&lt;strong&gt;&lt;em&gt;堆内存&lt;/em&gt;&lt;/strong&gt; 、&lt;strong&gt;&lt;em&gt;方法法区&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;栈&lt;/em&gt;&lt;/strong&gt;。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;em&gt;堆内存&lt;/em&gt;&lt;/strong&gt; 是JVM中最大的一块由 &lt;strong&gt;年轻代&lt;/strong&gt;和 &lt;strong&gt;老年代&lt;/strong&gt; 组成，而年轻代内存又被分为三部分， &lt;strong&gt;Eden空间&lt;/strong&gt; 、&lt;strong&gt;From Survivo空间&lt;/strong&gt; 、&lt;strong&gt;To Survivor空间&lt;/strong&gt; ，默认情况下年轻代按照$8:1:1$的比例来分配；&lt;font color=&quot;#FF3030&quot;&gt;方法区存储类信息、常量、静态变量等数据，是线程共享的区域&lt;/font&gt; ，为与&lt;strong&gt;Java堆&lt;/strong&gt;区分，方法区还有一个别名NonHeap(非堆)；栈又分为 &lt;strong&gt;Java虚拟机栈&lt;/strong&gt; 和 &lt;strong&gt;本地方法栈&lt;/strong&gt; 主要用于方法的执行。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;font color=&quot;#FF0000&quot;&gt;JAVA的JVM的内存可分为3个区&lt;/font&gt;： &lt;strong&gt;堆(Heap)&lt;/strong&gt;、 &lt;strong&gt;栈(Stack)&lt;/strong&gt;  、 &lt;strong&gt;方法区(Method Area)&lt;/strong&gt; 。实际IDEA开发Tomcat启动项配置示例：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;font face=&quot;微软雅黑&quot; color=&quot;#9900ff&quot; size=&quot;2&quot;&gt;-Xms1024m -Xmx1024m  -XX:PermSize=512M -XX:MaxPermSize=1024m  -Dfile.encoding=utf-8 &lt;/font&gt;   



&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构(3)</title>
    <link href="http://edgeowner.com/2016/04/26/JVM/JVM3/"/>
    <id>http://edgeowner.com/2016/04/26/JVM/JVM3/</id>
    <published>2016-04-26T10:00:00.000Z</published>
    <updated>2016-04-27T04:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h4 id="JVM具体参数和内存区域映射图例"><a href="#JVM具体参数和内存区域映射图例" class="headerlink" title="JVM具体参数和内存区域映射图例"></a>JVM具体参数和内存区域映射图例</h4><p> &emsp;&emsp;此文主要用图例方式描绘了JVM的结构，介绍了JVM内存结构对应的参数名。</p><ul><li>在具体实现上，JVM将需要进行垃圾回收的区域分为3类：新生代（Young Generation）、老年代(Old Generation)、永久代(Permanent Generation)。其中新生代又分为eden和survival（S0、S1），具体结构如下图所示：</li><li><img src="http://p5vswdxl9.bkt.clouddn.com/jvm_and_params_map.png" alt="图示1.0"><a id="more"></a></li><li>简单讲，新生代的eden、新生代的survival、老生代里的对象存活时间依次变长。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>参数名称</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td style="text-align:left">-Xmx</td><td>初始堆大小</td></tr><tr><td style="text-align:left">-Xms</td><td>最大堆大小</td></tr><tr><td style="text-align:left">-Xss</td><td>每个线程的堆栈大小</td></tr><tr><td style="text-align:left">-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td></tr><tr><td style="text-align:left">-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td></tr><tr><td style="text-align:left">-XX:PermSize</td><td>设置持久代(perm gen)初始值</td></tr><tr><td style="text-align:left">-XX:MaxPermSize</td><td>设置持久代最大值</td></tr><tr><td style="text-align:left">-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td></tr><tr><td style="text-align:left">-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td></tr></tbody></table></div><hr><h4 id="JVM内存结构图例"><a href="#JVM内存结构图例" class="headerlink" title="JVM内存结构图例"></a>JVM内存结构图例</h4><p><img src="http://p5vswdxl9.bkt.clouddn.com/JVM_Flow.jpg" alt=""><br>   &emsp;&emsp;方法区和堆是所有<strong>线程共享的内存区域</strong>；而java栈、本地方法栈和程序计数器是运行是<strong>线程私有的内存区域</strong>。</p><ul><li><p>Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p></li><li><p>方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></li><li><p>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p></li><li><p>本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p></li><li><p>ClassLoader是负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p></li><li><p>Native Interface是负责调用本地接口的。他的作用是调用不同语言的接口给JAVA用，他会在Native Method Stack中记录对应的本地方法，然后调用该方法时就通过Execution Engine加载对应的本地lib。原本多于用一些专业领域，如JAVA驱动，地图制作引擎等，现在关于这种本地方法接口的调用已经被类似于Socket通信，WebService等方式取代。</p></li><li><p>Execution Engine是执行引擎，也叫Interpreter。Class文件被加载后，会把指令和数据信息放入内存中，Execution Engine则负责把这些命令解释给操作系统。</p></li><li><p>Runtime Data Area则是存放数据的，分为五部分：Stack，Heap，Method Area，PC Register，Native Method Stack。几乎所有的关于java内存方面的问题，都是集中在这块。下图是javapapers.com上关于Run-time Data Areas的描述：<img src="http://p5vswdxl9.bkt.clouddn.com/JVM_2.jpg" alt=""></p></li></ul><hr><h4 id="相关技术参考"><a href="#相关技术参考" class="headerlink" title="相关技术参考"></a>相关技术参考</h4><ol><li><a href="https://www.jianshu.com/p/be6f529160b6" target="_blank" rel="noopener">JVM原理分析</a></li><li><a href="https://mp.weixin.qq.com/s/ebg0bT_xBahGV7OAKorBAw" target="_blank" rel="noopener">JVM知识点总览</a></li><li><a href="https://juejin.im/post/5a1cc3596fb9a04506715aad" target="_blank" rel="noopener">JVM系列之GC</a></li><li><a href="https://juejin.im/post/59ad4cd56fb9a02477075780#heading-5" target="_blank" rel="noopener">重读 JVM</a></li><li><a href="https://mijack.github.io/2018/03/18/Garbage-Collection/" target="_blank" rel="noopener">JVM 的内存模型</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JVM具体参数和内存区域映射图例&quot;&gt;&lt;a href=&quot;#JVM具体参数和内存区域映射图例&quot; class=&quot;headerlink&quot; title=&quot;JVM具体参数和内存区域映射图例&quot;&gt;&lt;/a&gt;JVM具体参数和内存区域映射图例&lt;/h4&gt;&lt;p&gt; &amp;emsp;&amp;emsp;此文主要用图例方式描绘了JVM的结构，介绍了JVM内存结构对应的参数名。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在具体实现上，JVM将需要进行垃圾回收的区域分为3类：新生代（Young Generation）、老年代(Old Generation)、永久代(Permanent Generation)。其中新生代又分为eden和survival（S0、S1），具体结构如下图所示：&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://p5vswdxl9.bkt.clouddn.com/jvm_and_params_map.png&quot; alt=&quot;图示1.0&quot;&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://edgeowner.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://edgeowner.com/tags/JVM/"/>
    
  </entry>
  
</feed>
