<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo搭建指南（一）]]></title>
    <url>%2F2018%2F04%2F03%2FHexo%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <url>%2F2018%2F03%2F13%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Serialize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java NIO]]></title>
    <url>%2F2018%2F03%2F13%2FJava-NIO%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java LDAP]]></title>
    <url>%2F2018%2F03%2F13%2FJava-LDAP%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java CAS]]></title>
    <url>%2F2018%2F03%2F13%2FJava-CAS%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java面试题目集锦 (1)]]></title>
    <url>%2F2016%2F06%2F01%2FJava%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java面试题目汇总</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存结构(3)]]></title>
    <url>%2F2016%2F04%2F26%2FJVM3%2F</url>
    <content type="text"><![CDATA[JVM具体参数和内存区域映射图例 &emsp;&emsp;此文主要用图例方式描绘了JVM的结构，介绍了JVM内存结构对应的参数名。 在具体实现上，JVM将需要进行垃圾回收的区域分为3类：新生代（Young Generation）、老年代(Old Generation)、永久代(Permanent Generation)。其中新生代又分为eden和survival（S0、S1），具体结构如下图所示： 简单讲，新生代的eden、新生代的survival、老生代里的对象存活时间依次变长。 参数名称 含义 -Xmx 初始堆大小 -Xms 最大堆大小 -Xss 每个线程的堆栈大小 -XX:NewSize 设置年轻代大小(for 1.3/1.4) -XX:MaxNewSize 年轻代最大值(for 1.3/1.4) -XX:PermSize 设置持久代(perm gen)初始值 -XX:MaxPermSize 设置持久代最大值 -XX:NewRatio 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) -XX:SurvivorRatio Eden区与Survivor区的大小比值 JVM内存结构图例 &emsp;&emsp;方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序计数器是运行是线程私有的内存区域。 Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。 JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。 ClassLoader是负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。 Native Interface是负责调用本地接口的。他的作用是调用不同语言的接口给JAVA用，他会在Native Method Stack中记录对应的本地方法，然后调用该方法时就通过Execution Engine加载对应的本地lib。原本多于用一些专业领域，如JAVA驱动，地图制作引擎等，现在关于这种本地方法接口的调用已经被类似于Socket通信，WebService等方式取代。 Execution Engine是执行引擎，也叫Interpreter。Class文件被加载后，会把指令和数据信息放入内存中，Execution Engine则负责把这些命令解释给操作系统。 Runtime Data Area则是存放数据的，分为五部分：Stack，Heap，Method Area，PC Register，Native Method Stack。几乎所有的关于java内存方面的问题，都是集中在这块。下图是javapapers.com上关于Run-time Data Areas的描述：]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存结构(2)]]></title>
    <url>%2F2016%2F04%2F24%2Fjvm2%2F</url>
    <content type="text"><![CDATA[JVM内存结构（运行时数据区）该文承接JVM内存结构简介(1)博文主要介绍所有线程共享的区域(方法区 和堆))，本文简单介绍剩余JVM的是三个区域：Java栈(Java Stack)、本地方法栈(Native Method Stack)、程序计数器(Program Counter Register)。 三、Java虚拟机栈(Java Virtual Machine Stacks) 作用：描述的就是Java方法执行的内存模型。每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于存储局部变量表、操作栈、动态链接、方法出口等信息。每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈道出栈的过程。一个方法的执行过程就等同于栈帧进栈出栈的过程。 特点：线程私有的，生命周期和线程相同。栈是一个后进先出(LIFO)的数据结构，每次方法调用时，一个新的栈帧创建并被压栈到栈顶， 当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。除了栈帧的压栈和出栈，栈不能被直接操作。 在JVM中，若线程请求栈的深度 超过了虚拟机允许的最大深度 ，则会抛出StackOverflowError异常；当栈进行动态扩展，但 无法申请到相应内存空间（此时，线程请求的栈深度未超过虚拟机允许的最大深度）时，则会抛出OutOfMemoryError异常。 局部变量表：存放了编译期间可以知道大小的各种类型变量，它所需要的内存空间大小在编译期间就已经分配，当一个方法被调用时，栈帧进入虚拟机栈，在运行期间，局部变量表大小是不会变化的。 栈帧(Frame)：栈帧只存储指向堆中对象或数组的引用 ，包含局部变量数组、返回值、操作数栈、类当前方法运行时常量池引用： 局部变量数组：包含了方法执行过程中所有变量，包括this引用、所有方法参数、其他局部变量。对于类方法（也就是静态方法），方法参数从下标 0 开始，对于对象方法，位置0保留为 this。（boolean、byte、char、long、short、int、float、double、reference、returnAddress均为局部变量，除了 long 和 double 类型以外，所有的变量类型都占用局部变量数组的一个位置。long 和 double 需要占用局部变量数组两个连续的位置，因为它们是 64 位双精度，其它类型都是 32 位单精度。）操作数栈：在执行字节码指令过程中被用到，这种方式类似于原生CPU寄存器。大部分JVM字节码把时间花费在操作数栈的操作上：入栈 、出栈 、复制 、交换 、产生消费变量 的操作。因此，局部变量数组和操作数栈之间的交换变量指令操作通过字节码频繁执行。比如，一个简单的变量初始化语句将产生两条跟操作数栈交互的字节码。 关于局部变量数组、操作数栈和运行时常量池之间交互的详细信息，可以在类文件结构部分找到。 四、本地方法栈(Native Method Stack) 作用：Java虚拟机在实现时，可以根据自身需求，确定是否实现本地方法栈。在实现上，JVM可能会使用到传统的栈（通常称之为“C Stacks”）来支持 native 方法（指使用 Java 以外的其他语言编写的方法）的执行，这个栈就是本地方法栈。当JVM支持本地方法栈时，这个栈会在线程创建时按照线程分配。 在JVM中，本地方法栈可能发生的异常情况也分为Stack OverflowError和OutOfMemoryError异常，出错原因和虚拟机栈相似，此处不再赘述。 特点：Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。本地方法栈则是为虚拟机使用到的Native方法服务. 五、程序计数器(Program Counter Register) 程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 在任意时刻，一个Java虚拟机线程只会执行一个方法，而 PC Java 虚拟机允许多条线程同时执行。因此，每一条 Java虚拟机线程都有自己的 PC 寄存器 ，他们是相互独立的。每一条 Java虚拟机线程都有自己的PC 寄存器，他们是相互独立的。 我们称正在被线程执行的方法称为该线程的当前方法（Current Method）。如果这个方法不是 native 的，那 PC 寄存器就保存 Java 虚拟机正在执行的字节码指令的地址，如果该方法是 native 的，那 PC 寄存器的值是 undefined。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadPoolExecutor 参数详解]]></title>
    <url>%2F2016%2F04%2F21%2FThreadPoolExecutor%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java Multi-thread Programming</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadPoolExecutor 参数详解]]></title>
    <url>%2F2016%2F04%2F20%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java Multi-thread Programming</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存结构(1)]]></title>
    <url>%2F2016%2F04%2F19%2Fjvm%2F</url>
    <content type="text"><![CDATA[JVM内存结构（运行时数据区）JVM内存结构指得是：运行时数据区（Runtime Data Area），由 方法区(Method Area) 、堆(Heap) 、Java栈(Java Stack) 、本地方法栈(Native Method Stack)、程序计数器(Program Counter Register)。 一、方法区(Method Area) 作用： 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。此区域内存回收目标主要针对常量池回收和对类型的卸载回收。 特点：线程共享 。 永久代的疑问(PerGen)：该内存区域一般被称为”_永久代(Permanent Generation)_ “，二者并不等价，设计之初就把GC分代收集扩展至方法区，或者说使用永久代实现方法区而已。 运行时常量池：方法区的一部分，存放编译期生成的各种字面量(“zdy”,”123”等)和 符号引用 。编译器和运行期的intern()都可以将常量放入池中。受方法区限制，常量池无法申请到内存时会抛出OutOfMemoryError异常。运行时常量池具有动态性，并非只有Class文件中的内容才能进入运行时常量池，运行期间也能将新的常量放入池中。如String.intern（）方法。 方法区储存类的信息： Classloader引用； 运行时常量池：数值型常量、字段引用、方法引用、属 性； 字段数据：针对每个字段的信息、字段名、类型、修饰符、属性； 方法数据：每个方法、方法名、返回值类型、参数类型、修饰符、属性； 方法代码：每个方法、字节码、操作数栈大小、局部变量大小、局部变量表、异常表、每个异常处理器、开始点、结束点、异常处理代码的程序计数器偏移量、被捕获异常类对应的常量池下标； 字面量(literal) ：由字母，数字等构成的字符串或者数值，用于表达源代码中一个固定值的表示法(notation)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。 符号引用 ：简单地说就是，符号引用存在class文件中的常量池，包括类和接口的全限定名、字段的名称和描述符以及方法的名称和描述符。jvm加载class的时候就可以凭着这三者进行动态连接，得到具体的内存地址。占用的数据结构在常量池项目类型有，例如类或接口的符号引用结构为u1的tag和u2的name_index。 二、堆(Heap) 作用 ：被所有线程运行时共享的内存区域，JVM启动之后，存放对象实例和数组，内部会划出多个线程私有的分配缓冲区(Thread Location Allocation Buffer ,TLAB)。该存储区域物理上可以是不连续空间，但是逻辑上一定要连续。 特点 ：是GC管理的主要区域，由于GC（垃圾收集器）是采用分代收集算法,根据对象存活率，堆还可以分为新生代、老年代、永久代。 分类 ： _新生代(Young Generation)_ ：方法中去new一个对象，那这方法调用完毕后，对象就会被回收，这就是一个典型的新生代对象。 每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后清理Eden和刚才用过的Survivor空间。 HotSpot虚拟机默认Eden和Survivor的大小比例是8:1 ，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。 98%的对象可回收只是一般场景下的数据，没办法保证每次回收都只有不多于10%的对象存活，当Survivor不够用时，需要依赖于老年代进行分配担保，所以 大对象 直接进入老年代。同时长期存活的对象进入老年代（虚拟机给每个对象定义一个年龄计数器）。年轻代内存又被分成三部分： Eden空间：对象优先分配在Eden区，若Eden区无足够的空间，虚拟机执行一次Minor GC。对象被创建时首先放到这个区域，进行垃圾回收后，不能被回收的对象被放到空的Survivor区域。 Survivor Space幸存者区：用于保存在Eden Space内存区域中经过垃圾回收后没有被回收的对象。Survivor有两类，分别为To Suvivor 和 From Suvivor两个区域，这两个区域空间大小是一样的执行： &emsp;&emsp;a.From Survivor空间： &emsp;&emsp;b.To Survivor空间 ： 执行回收的内存运行： 执行垃圾回收时Eden区域不能被回收的对象被放入到空的Suvivor(也就是To Survivor，同时Eden区域的内存会在垃圾回收的过程中全部释放)，另一个Survivor(即From Survivor)里不能被回收的对象也会被放入到Survivor(即To Survivor)，然后To Survivor和 From Survivor的标记会互换，始终保证一个Survivor是空的。 _老年代(Old Generation)_ ： 老年代空间大小&emsp;=&emsp;堆空间大小&emsp;—&emsp;年轻代大空间大小 年轻代的垃圾回收 ：Eden Space(伊甸园) 和Suvivor Space 都属于新生代，新生代中执行垃圾回收被称为Minor GC(由于是对新生代进行垃圾回收，所以被称为Young GC)，每次Young GC 后留下来的对象age +1。 _ Eden:From:TO =8:1:1_ 由于新生代中90%的对象都是”朝生夕死”，采用复制算法是比较合理的，首先只移动了存活下来的对象(比较少数),其次内存在移动到To区域后是有顺序的，不存在内存碎片。值得一提的是，假如在一次Minor GC时,Eden中存活的对象+From中存活的对象&gt;To的剩余空间，则会通过担保机制将对象直接转移到Old Gen ,如果Old Gen的内存空间也不够，则进行一次Full GC .当 对象的年龄到达15岁时会转移到Old Gen(可通过参数配置，一般不建议更改) 使用方式 ：Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 对象分配规则： 1.对象优先分配在Eden区：若Eden区没有足够的空间时，虚拟机执行一次Minor GC； 2.大对象(大对象是指需要大量连续内存空间的对象)直接进入老年代：这样做目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝(新生代采用 复制算法 收集内存)； 3.长期存活的对象进入老年代：虚拟机为每个对象定义一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象年龄加 1，直到达到阀值，对象进入老年区； 4.动态判断对象的年龄：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代； 5.空间分配担保：每次每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC，如果false则进行Full GC；]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaCore（1）]]></title>
    <url>%2F2015%2F04%2F13%2FJava-Core%2F</url>
    <content type="text"><![CDATA[Java核心Java基本语法：Java类和对象：Java集合：Java泛型：Java注解：Java反射：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序（Merge Sort）]]></title>
    <url>%2F2015%2F03%2F28%2FmergeSort%2F</url>
    <content type="text"><![CDATA[归并排序归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并过程为：比较$a[i]$和$b[j]$的大小，若$a[i]≤b[j]$，则将第一个有序表中的元素$a[i]$复制到$r[k]$中，并令$i$和$k$分别加上$1$；否则将第二个有序表中的元素$b[j]$复制到$r[k]$中，并令$j$和$k$分别加上$1$，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到$r$中从下标$k$到下标$t$的单元。归并排序的算法我们通常用递归实现，先把待排序区间$[s,t]$以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间$[s,t]$。 算法思路Selection Sort、Bubble Sort、Insertion Sort is $O(n^2)$ in average case , Merge Sort $O(n log(n))$ in worst case. In this sorting algorithm we use the idea of divide and conquer. We divide the array into two parts, sort them and then merge them to get the elements in ascending or descending order. Merge sorting is done recursively. We take an array and keep dividing from the middle till we get only one element in each halves(sub-array). The we sort the sub-arrays and join (merge) them back to get the final sorted array. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤3直到某一指针超出序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾 总结： 将两个已排好序的数组合并成一个有序的数组,称之为归并排序； 步骤：遍历两个数组，比较它们的值。谁比较小，谁先放入大数组中，直到数组遍历完成； 算法动态展示 YouTube视频源地址 ; Merge Sort - step by step guide;In this video beg and end are pointing at array index not the value at the array index. 开课老师视频源; MycodeSchool (function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/mergeSort.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 代码实现方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 归并排序 * * @param arrs */ public static void mergeSort(int[] arrs) &#123; if (arrs == null || arrs.length == 0 || arrs.length == 0) &#123; return; &#125; mergeSort(arrs, 0, arrs.length - 1); &#125; /** * 归并排序核心部分(递归调用) * * @param arrs * @param left * @param right */ private static void mergeSort(int[] arrs, int left, int right) &#123; //如果只有一个元素就不用排序 if (left == right) &#123; return; &#125; else &#123; //取消中间数，进行拆分 int middle = (left + right) / 2; //左边的数不断进行拆分 mergeSort(arrs, left, middle); //右边的数不断进行拆分 mergeSort(arrs, middle + 1, right); //合并 merge(arrs, left, middle + 1, right); &#125; &#125; /** * 合并数组 * * @param arrs * @param left 指向数组第一个元素 * @param middle 指向数组分隔的元素 * @param right 指向数组最后的元素 */ private static void merge(int[] arrs, int left, int middle, int right) &#123; //左边的数组大小 int[] leftArrs = new int[middle - left]; //右边的数组大小 int[] rightArrs = new int[right - middle + 1]; //往这两个数组填充数据 for (int i = left; i &lt; middle; i++) &#123; leftArrs[i - left] = arrs[i]; &#125; for (int i = middle; i &lt;= right; i++) &#123; rightArrs[i - middle] = arrs[i]; &#125; int i = 0, j = 0; //arrs数组的第一个元素 int k = left; //比较两个数组的值，哪个小，就往数组上放 while (i &lt; leftArrs.length &amp;&amp; j &lt; rightArrs.length) &#123; //谁比较小，谁将元素放入大数组中，移动指针，继续比较下一个 if (leftArrs[i] &lt; rightArrs[j]) &#123; arrs[k] = leftArrs[i]; i++; k++; &#125; else &#123; arrs[k] = rightArrs[j]; j++; k++; &#125; &#125; //如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字) while (i &lt; leftArrs.length) &#123; arrs[k] = leftArrs[i]; i++; k++; &#125; //如果右边的数组还没比较晚，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字) while (j &lt; rightArrs.length) &#123; arrs[k] = rightArrs[j]; k++; j++; &#125; &#125; 参考地址：归并排序]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基数排序（Radix Sort）]]></title>
    <url>%2F2015%2F03%2F27%2FradixSort%2F</url>
    <content type="text"><![CDATA[基数排序基数排序(radix sort)属于”分配式排序”(distribution sort)，又称”桶子法”(bucket sort)或bin sort，将要排序的元素分配至某些”桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为$O(n log(r)m)$，其中$r$为所采取的基数，而$m$为堆数，空间复杂度$O(N)$，在某些时候，基数排序法的效率高于其它的稳定性排序法。基数排序是按照分配，回收（分配到不同的位置上，然后回收）...不断分配...回收来进行排序，直到有序...。 算法思路It is a sorting algorithm that is used to sort numbers. We sort the numbers from least significant digit to the most significant digit. When we are sorting the numbers we will first find the number of digits in the biggest number. If there are N digits in the biggest number then we will need to perform N number of pass. We will pad the remaining numbers with leading zeros so they all have N digits. Then we will take 10 buckets labeled 0 to 9 and sort the numbers. After the sorting is complete we will remove the leading zeros. 基数排序的要点就两个： 分配：按照元素的大小来放入不同的桶子里； 回收：将桶子里的元素按桶子顺序重新放到数组中； 重复…..两个步骤； 基数排序对有负数和0的数列难以进行排序 算法动态展示 YouTube视频源地址 ; Radix Sort - step by step guide; 开课老师视频源; (function(){var player = new DPlayer({"container":document.getElementById("dplayer5"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/QQ20180403-113850-HD.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 代码实现方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 基数排序 * * @param arrs */ public static void radixSort(int[] arrs) &#123; int max = findMax(arrs, 0, arrs.length - 1); //需要遍历的次数由数组最大的位数来决定 for (int i = 1; max / i &gt; 0; i = i * 10) &#123; int[][] buckets = new int[arrs.length][10]; //获取每一个数字（个、十、百、千位...分配到桶子里） for (int j = 0; j &lt; arrs.length; j++) &#123; int num = (arrs[j] / i) % 10; //将其放入桶子里 buckets[j][num] = arrs[j]; &#125; //回收桶子里的元素 int k = 0; //有10个桶子 for (int j = 0; j &lt; 10; j++) &#123; //对每个桶子里的元素进行回收 for (int l = 0; l &lt; arrs.length; l++) &#123; //如果桶子里有元素就回收(数据会初始化为0) if (buckets[l][j] != 0) &#123; arrs[k++] = buckets[l][j]; &#125; &#125; &#125; &#125; &#125; /** * 递归找出数组最大值 * * @param arrs 数组 * @param left 左边界，第一个数 * @param right 右边界，数组长度 * @return */ public static int findMax(int[] arrs, int left, int right) &#123; //若该数组只有一个数，那么最大的就是该数组第一个值 if (left == right) &#123; return arrs[left]; &#125; else &#123; int leftValue = arrs[left]; //找出所有元素中的最大值 int rightvalue = findMax(arrs, left + 1, right); if (leftValue &gt; rightvalue) &#123; return leftValue; &#125; else &#123; return rightvalue; &#125; &#125; &#125; 参考地址：基数排序]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计数排序（Counting Sort）]]></title>
    <url>%2F2015%2F03%2F27%2FcountingSort%2F</url>
    <content type="text"><![CDATA[计数排序计数排序是一种稳定的线性时间排序算法。计数排序使用一个额外的数组 $C$ ，其中第i个元素是待排序数组 $A$中值等于 $i$ 的元素的个数。然后根据数组 $C$ 来将 $A$ 中的元素排到正确的位置。当输入的元素是 $n$ 个 $0$到 $k$ 之间的整数时，它的运行时间是 $\Theta (n+k)$ 。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组$C$ 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 $1$），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序$0$到 $100$ 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序算法中，能够更有效的排序数据范围很大的数组。 计数排序(Counting Sort)是一种$O(n)$的排序算法，其思路是开一个长度为$maxValue-minValue+1$的数组，然后分配。扫描一遍原始数组，以当前值$-minValue$作为下标，将该下标的计数器增$1$。 收集。扫描一遍计数器数组，按顺序把值收集起来。 计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序。 算法思路Counting sort is a sorting technique based on keys between a specific range, it works by counting the number of objects having distinct key values.Then doing some arithmetic to calculate the position of each object in the output sequence. Create a count array to store the count of each unique object; Initially the count of all elements is zero ; Count each elements in the given array and place the count at the appropriate index; Modify the count array by adding the previous counts; Corresponding values represent the places in the count array; We place the objects in their correct positions and decrease the count by one; 翻译 找出待排序的中最大元素和最小元素； 统计数组中每个值为 $i$ 的元素出现的次数，存入数组 $C$的第$i$项； 对所有的技术累加（ $C$ 中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组；将每个元素 $i$ i放在新数组的第$C[i]$项，每放一个元素就将 $C[i]$减去$1$ ； 算法动态展示 YouTube视频源地址 ; Counting Sort - step by step guide; (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/QQ20180402-174913-HD.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 代码实现方式1234567891011121314151617181920212223242526272829303132333435363738/** * 计数排序 * * @param arrs */ public static void countingSort(int[] arrs) &#123; int[] copyData = Arrays.copyOf(arrs, arrs.length); int maxValue = arrs[0]; int minValue = arrs[0]; for (int i = 0; i &lt; copyData.length; i++) &#123; if (copyData[i] &gt; maxValue) &#123; maxValue = copyData[i]; &#125; if (copyData[i] &lt; minValue) &#123; minValue = copyData[i]; &#125; &#125; int range = maxValue - minValue + 1; int[] counts = new int[range]; Arrays.fill(counts, 0); // 计算数组中每个值和最小值的差，并计数 for (int arr : copyData) &#123; counts[arr - minValue]++; &#125; // 得到数组中大于某个数的值一共有多少个 for (int i = 1; i &lt; counts.length; i++) &#123; counts[i] = counts[i] + counts[i - 1]; &#125; // 根据数量放置值，每放置一个，对应的值的数量减一 for (int i = 0; i &lt; copyData.length; i++) &#123; int index = copyData[i] - minValue; arrs[counts[index] - 1] = copyData[i]; counts[index]--; &#125; &#125; 参考地址：计数排序]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序（Shell Sort）]]></title>
    <url>%2F2015%2F03%2F25%2FshellSort%2F</url>
    <content type="text"><![CDATA[希尔排序希尔排序也称为递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是基于插入排序的一下两点性质而提出改进方法的： 插入排序在对几乎已经安排好序的数据操作时，效率高，即可达到线性排序的效率 插入排序一般来说是抵消的，因为插入排序每次只能将数据移动一位从专业的角度上讲，将一个序列分成好几个序列，用一个数来表示：那个数称为增量。显然的是，增量是不断递减的(直到增量为$1$) 希尔排序的平均复杂度是$O(N*logN)~O(N^2)$，最好的情况$O(N^1.3)$，最坏的情况$O(N^2)$；空间复杂度$O(1)$;不稳定算法 算法思路In this sorting algorithm we compare elements that are distant apart rather than adjacent. Shell sort is like insertion sort. We start by comparing elements that are at a certain distance apart.So if there are N elements then we start with a value gap &lt; N In each pass we keep reducing the value of gap till we reach the last pass when gap is 1 Note!, when gap = 1,shell sort is like insertion sort and we will have sorted elements at the end of this pass; 算法动态展示 YouTube视频源地址 ; Shell Sort - step by step guide; 开课老师视频源; (function(){var player = new DPlayer({"container":document.getElementById("dplayer6"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/QQ20180328-201843-HD.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 代码实现方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 希尔排序 * * @param arrs */ public static void shellSort(int[] arrs) &#123; if (arrs == null || arrs.length == 0) &#123; return; &#125; //增量 每次都 gap/2 gap为每次外循环的步长 //当 步长为 1 即增量为1 时， 希尔排序蜕化为 简单插入排序 int counterFrequency = 0; for (int gap = (int) Math.floor(arrs.length / 2); gap &gt; 0; gap /= 2) &#123; counterFrequency++; System.out.println("------------------1.Outerloop start---------------------"); System.out.println(MessageFormat.format("--------1.Increment:&#123;0&#125;, outerloop frequency:&#123;1&#125;---------", gap, counterFrequency)); for (int i = gap; i &lt; arrs.length; i++) &#123; int j = i; int temp = arrs[j]; // j - step 就是代表与它同组隔壁的元素 内层增量 gap通过 j-gap确定左边 int counterSwapJGap = 0; while (j - gap &gt;= 0 &amp;&amp; arrs[j - gap] &gt; temp) &#123; arrs[j] = arrs[j - gap]; j = j - gap; counterSwapJGap++; printArr("--------------1. arrs:&#123;0&#125;---------------",arrs); &#125; printArr("--------------2. arrs:&#123;0&#125;---------------",arrs); System.out.println(MessageFormat.format("------------------3.Whileloop counter:&#123;0&#125;---------------------", counterSwapJGap)); arrs[j] = temp; System.out.println(MessageFormat.format("--------2.Innerloop: i:&#123;0&#125;, j:&#123;1&#125; , temp:&#123;2&#125; ---------", i, j, temp)); &#125; System.out.println("------------------1.Outerloop over---------------------"); &#125; &#125; //对比简单插入排序 /** * 简单插入排序 * * @param arrs */ public static void insertSortDemo(int arrs[]) &#123; int len = arrs.length; for (int i = 1; i &lt; len; i++) &#123; for (int j = i; j &lt; len - 1; j--) &#123; if (arrs[j] &lt; arrs[j - 1]) &#123; int temp = arrs[j]; arrs[j] = arrs[j - 1]; arrs[j - 1] = temp; &#125; &#125; &#125; &#125; / /** * 打印数组 * * @param str * @param arrs */ private static void printArr(String str, int[] arrs) &#123; String result = ""; StringBuilder sb = new StringBuilder(); if (str != null) &#123; sb.append("["); for (int i = 0; i &lt; arrs.length; i++) &#123; sb.append("," + arrs[i]); &#125; sb.append("]"); result = sb.toString().replaceFirst(",", ""); result = MessageFormat.format(str, result); &#125; else &#123; sb.append("["); for (int i = 0; i &lt; arrs.length; i++) &#123; sb.append("," + arrs[i]); &#125; sb.append("]"); result = sb.toString().replaceFirst(",", ""); &#125; System.out.println("result:" + result); &#125; 参考地址：希尔排序]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序（Heap Sort）]]></title>
    <url>%2F2015%2F03%2F24%2FheapSort%2F</url>
    <content type="text"><![CDATA[堆排序堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。大堆小堆图例：简单来说：堆排序是将数据看成是完全二叉树、根据完全二叉树的特性来进行排序的一种算法。最大堆要求节点的元素都要不小于其孩子，最小堆要求节点元素都不大于其左右孩子。那么处于最大堆的根节点的元素一定是这个堆中的最大值。完全二叉树有个特性：左边子节点位置 = 当前父节点的两倍 + 1，右边子节点位置 = 当前父节点的两倍 + 2点击参考文章 算法思路这里我们讨论最大堆：当前每个父节点都大于子节点。In this Algorithm we first build the heap using the given elements, We create a Max Heap to sort the elements in ascending order , Once the heap iscreated we swap the root node with the last node an delete the last node from the heap。 Build a heap we need transform it into to a max heap ; Create a Max heap (this Max heap parent node is always greater than or equal to child nodes); Remove the node ,in anther way :Swap first and last node and delete the last node from heap; Repeat the 1,2,3 step ,always build the max heap; 算法动态展示： YouTube视频源地址 Heap Sort - step by step guide; (function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/QQ20180328-140208-HD.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 代码实现方式(关键节点添加输出标注，可自行追踪执行过程)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 堆排序 * * @param arrs */ public static void heapSort(int[] arrs) &#123; if (arrs == null || arrs.length == 0) &#123; return; &#125; int len = arrs.length; //循环建立最大堆 for (int i = 0; i &lt; len; i++) &#123; System.out.println(MessageFormat.format("1. heapSort: i,&#123;0&#125; j,&#123;1&#125;", i, len - 1)); System.out.println("--------------1. buildMaxHeap start--------------"); buildMaxHeap(arrs, len - i); //交换堆顶和最后一个元素 int temp = arrs[0]; arrs[0] = arrs[len - 1 - i]; arrs[len - 1 - i] = temp; System.out.println("--------------1. buildMaxHeap over--------------"); &#125; &#125; /** * 完成最大堆建立 * * @param arrs * @param len */ private static void buildMaxHeap(int[] arrs, int len) &#123; System.out.println("--------------2. buildMaxHeap method start--------------"); System.out.println(MessageFormat.format("--------------2. params:&#123;0&#125;--------------",len)); for (int j = (int) Math.floor(len / 2); j &gt;= 0; j--) &#123; heapify(arrs, j, len); &#125; &#125; /** * 建立堆 (大顶堆方式) * * @param arrs 完全二叉树 * @param currentRooNode 当前父节点位置 * @param length 节点总数 */ private static void heapify(int[] arrs, int currentRooNode, int length) &#123; System.out.println("--------------3. heapify method start--------------"); System.out.println(MessageFormat.format("--------------3. params:&#123;0&#125;,&#123;1&#125;-------------", currentRooNode, length)); if (currentRooNode &lt; length) &#123; //左叶子结点 位置 int left = 2 * currentRooNode + 1; //右叶子结点 位置 int right = 2 * currentRooNode + 2; int max = currentRooNode; if (left &lt; length) &#123; //如果当前根节点的 左叶子节点元素值较大，记录它的位置 if (arrs[max] &lt; arrs[left]) &#123; max = left; &#125; &#125; if (right &lt; length) &#123; //如果当前根节点的 右叶子节点元素值较大，记录它的位置 if (arrs[max] &lt; arrs[right]) &#123; max = right; &#125; &#125; //如果最大的不是根元素位置，那么就交换 if (max != currentRooNode) &#123; int temp = arrs[max]; arrs[max] = arrs[currentRooNode]; arrs[currentRooNode] = temp; //继续比较，直到完成一次建堆 heapify(arrs, max, length); &#125; &#125; System.out.println("--------------3. heapify method over--------------"); &#125; 参考地址：堆排序]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序（Quick Sort）]]></title>
    <url>%2F2015%2F03%2F24%2FquickSort%2F</url>
    <content type="text"><![CDATA[快速排序快速排序是冒泡排序的改进版，是最好的一种内排序，面试会经常被问到，是程序员必须掌握的。 算法思路快速排一般基于递归实现： 选定一个合适的值（理想情况中值最好。实现中一般使用数组第一个值），称为“枢轴”（pivot）。 基于这个值，将数组分为两部分，较小的分在左边，较大的分在右边。 一轮下来，这个枢轴的位置一定在最终位置上。 对两个子数组分别重复上述过程，直到每个数组只有一个元素。 排序完成。 快速排序示意图：图例过程演示（中文原视频地址）： (function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/QQ20180327-124320-HD.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() (function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p5vswdxl9.bkt.clouddn.com/QQ20180327-124538-HD.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 超有趣的快速排序视频 代码实现方式（为了更直观的反映整个排序过程添加了标记代码）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private static void quickSort2(int arr[], int left, int right) &#123; //如果left不小于right ，需要排序的部分只有一个元素，方法返回 System.out.println("left:" + left + ",right:" + right); if (left == 0 &amp;&amp; right == 0) &#123; System.out.println("i=j=0"); &#125; System.out.println("1.-------------------"); if (left &gt;= right) &#123; System.out.println(MessageFormat.format("return: left,&#123;0&#125; | right,&#123;1&#125;", left, right)); return; &#125; //设置最左边元素为基准点：pivot int pivot = arr[left]; System.out.println("pivot:" + pivot); int i = left; int j = right; //把要排序的序列中比p大的放到右边，比p小的放到左边，p的下标位置为i while (i &lt; j) &#123; System.out.println("2.-------start------------"); while (i &lt; j &amp;&amp; arr[j] &gt;= pivot) &#123; j--; System.out.println("2. j:" + j); &#125; System.out.println("========[j-- over, i++ start ]=========="); while (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123; i++; System.out.println("2. i:" + i); &#125; System.out.println("2.-------end------------"); if (i &lt; j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; //交换基准点 arr[left] = arr[i]; arr[i] = pivot; //对序列中，i左边的元素实施快速排序 System.out.println("左边开始前， right为" + right + "值"); quickSort2(arr, left, i - 1); //对序列中，j右边边的元素实施快速排序 System.out.println("右块遍历开始...... "); quickSort2(arr, i + 1, right); System.out.println("left =:" + (i + 1) + ",right = " + right); System.out.println("3.-------------------"); System.out.println("4.---------all over----------"); 12345678910111213public static void quickSort(int[] arr) &#123; //大数据量测试 int[] arr = new int[100000]; Random r = new Random(); for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = r.nextInt(10000000); &#125; long start = System.currentTimeMillis(); quickSort(nums); long time = System.currentTimeMillis() - start; System.out.println("-----------大数据量测试结果-----------"); System.out.println("all time:" + time + "毫秒"); &#125; 参考地址：]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之线性排序]]></title>
    <url>%2F2015%2F03%2F22%2Flinear%2F</url>
    <content type="text"><![CDATA[线性排序：计数排序 、桶排序 、基数排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶；计数排序：每个桶只存储单一键值；桶排序：每个桶存储一定范围的数值； 计数排序：计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。基本思想 遍历流程图例 代码实现1234567891011121314151617181920212223242526272829303132333435private static int[] counterSort(int[] arr) &#123; if (null == arr || arr.length == 0) &#123; return arr; &#125; int maxValue = getMaxValue(arr); return countingSort(arr, maxValue); &#125; private static int[] countingSort(int[] arr, int maxValue) &#123; int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) &#123; bucket[value]++; &#125; int sortedIndex = 0; for (int j = 0; j &lt; bucketLen; j++) &#123; while (bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr; &#125; private static int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125; 桶排序：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 基本思想 类似计数排序 遍历流程图例 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//桶值大小 private static int BUCKET_SIZE = 5; private static int[] bucketSort(int[] arr) &#123; if (arr.length == 0) &#123; return arr; &#125; int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) &#123; if (value &lt; minValue) &#123; minValue = value; &#125; else if (value &gt; maxValue) &#123; maxValue = value; &#125; &#125; int bucketCount = (int) Math.floor((maxValue - minValue) / BUCKET_SIZE) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int index = (int) Math.floor((arr[i] - minValue) / BUCKET_SIZE); buckets[index] = arrAppend(buckets[index], arr[i]); &#125; int arrIndex = 0; for (int[] bucket : buckets) &#123; if (bucket.length &lt;= 0) &#123; continue; &#125; // 对每个桶进行排序，这里使用了插入排序 bucket = insertSort(bucket); for (int value : bucket) &#123; arr[arrIndex++] = value; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private static int[] arrAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125; /** * 插入排序 * * @param arr * @return */ public static int[] insertSort(int[] arr) &#123; if (null == arr || arr.length == 0) &#123; return arr; &#125; // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt; arr.length; i++) &#123; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; // 记录要插入的数据 int tmp = arr[i]; while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; // 存在比其小的数，插入 if (j != i) &#123; arr[j] = tmp; &#125; &#125; return arr; &#125; 基数排序：基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基本思想 基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序； 分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中； 收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]；对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束； 根据上述“基数排序”的展示，我们可以清楚的看到整个实现的过程 LSD基数排序遍历流程图例 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private static int[] radixSort(int[] arr) &#123; if (null == arr || arr.length == 0) &#123; return arr; &#125; int maxDigit = getMaxDigit(arr); return radixSort(arr, maxDigit); &#125; /** * 获取最高位数 */ private static int getMaxDigit(int[] arr) &#123; int maxValue = getMaxValue(arr); return getNumLenght(maxValue); &#125; private static int getNumLenght(long num) &#123; if (num == 0) &#123; return 1; &#125; int lenght = 0; for (long temp = num; temp != 0; temp /= 10) &#123; lenght++; &#125; return lenght; &#125; private static int[] radixSort(int[] arr, int maxDigit) &#123; int mod = 10; int dev = 1; for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; for (int j = 0; j &lt; arr.length; j++) &#123; int bucket = ((arr[j] % mod) / dev) + mod; counter[bucket] = arrayAppend(counter[bucket], arr[j]); &#125; int pos = 0; for (int[] bucket : counter) &#123; for (int value : bucket) &#123; arr[pos++] = value; &#125; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private static int[] arrayAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125; private static int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之归并排序]]></title>
    <url>%2F2015%2F03%2F18%2Fdivision-recursion%2F</url>
    <content type="text"><![CDATA[分治递归思想排序： 归并排序：归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；自下而上的迭代； 基本思想 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 遍历流程图例 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243private static int[] merger2Sort(int[] arr) &#123; if (null == arr || arr.length == 0 || arr.length &lt; 2) &#123; return arr; &#125; return sort(arr);&#125;private static int[] sort(int[] arr) &#123; if (arr.length &lt; 2) &#123; return arr; &#125; int middle = (int) Math.floor(arr.length / 2); int[] left = Arrays.copyOfRange(arr, 0, middle); int[] right = Arrays.copyOfRange(arr, middle, arr.length); return merge(sort(left), sort(right));&#125;private static int[] merge(int[] left, int[] right) &#123; int[] result = new int[left.length + right.length]; int i = 0; while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if (left[0] &lt;= right[0]) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; else &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; &#125; while (left.length &gt; 0) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; while (right.length &gt; 0) &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; return result;&#125; 归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之高效排序]]></title>
    <url>%2F2015%2F03%2F16%2Fhigh-efficiency%2F</url>
    <content type="text"><![CDATA[高效排序快速排序 、堆排序 、希尔排序 快速排序： 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。快速排序的名字起的是简单粗暴，因为听到这个名字你就知道它存在的意义，就是快而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好。 基本思想 从数列中挑出一个元素，称为 “基准”(pivot); 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区(partition)操作()； 递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序； 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 遍历流程图例 代码实现1234567891011121314151617181920212223242526272829public static void quickSort(int[] arr) &#123; if (null == arr || arr.length == 0) &#123; return; &#125; quickSort(arr, 0, arr.length - 1); &#125; private static int[] quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr; &#125; private static int partition(int[] arr, int left, int right) &#123; //设定基准值(pivot) int pivot = left; int index = pivot + 1; for (int i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; SwapUtils.swap(arr, i, index); index++; &#125; &#125; SwapUtils.swap(arr, pivot, index - 1); return index - 1; &#125; 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 堆排序： 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。 基本思想 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤2，直到堆的尺寸为 1。 遍历流程图例 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142public static void heapSort(int[] arr) &#123; if (null == arr || arr.length == 0) &#123; return; &#125; int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i &gt; 0; i--) &#123; SwapUtils.swap(arr, 0, i); len--; heapify(arr, 0, len); &#125; &#125; private static void buildMaxHeap(int[] arr, int len) &#123; for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) &#123; heapify(arr, i, len); &#125; &#125; private static void heapify(int[] arr, int i, int len) &#123; int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; SwapUtils.swap(arr, i, largest); heapify(arr, largest, len); &#125; &#125; 堆排序的平均时间复杂度为 Ο(nlogn)。 希尔排序： 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。希尔排序是基于插入排序的以下两点性质而提出改进方法的：插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 基本思想 选择一个增量序列t1，t2，……，tk，其中ti &gt; tj,tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。 遍历流程图例代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 希尔排序 针对有序序列在插入时采用交换法 * * @param arr */ private static void shellSort(int[] arr) &#123; if (null == arr || arr.length == 0) &#123; return; &#125; //增量gap，并逐步缩小增量 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; //从第gap个元素，逐个对其所在组进行直接插入排序操作 for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; while (j - gap &gt;= 0 &amp;&amp; arr[j] &lt; arr[j - gap]) &#123; SwapUtils.swap(arr, j, j - gap); j -= gap; &#125; &#125; &#125; &#125; /** * 希尔排序 针对有序序列在插入时采用移动法。 * * @param arr */ private static void shellSort2(int[] arr) &#123; if (null == arr || arr.length == 0) &#123; return; &#125; //增量gap，并逐步缩小增量 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; //从第gap个元素，逐个对其所在组进行直接插入排序操作 for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[j]; while (j - gap &gt;= 0 &amp;&amp; arr[j] &lt; arr[j - gap]) &#123; //移动法 arr[j] = arr[j - gap]; j -= gap; &#125; arr[j] = temp; &#125; &#125; &#125; 希尔排序中对于增量序列的选择十分重要，直接影响到希尔排序的性能。我们上面选择的增量序列{n/2,(n/2)/2…1}(希尔增量)，其最坏时间复杂度依然为O(n2)，一些经过优化的增量序列如Hibbard经过复杂证明可使得最坏时间复杂度为O(n3/2)。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之简单排序]]></title>
    <url>%2F2015%2F03%2F14%2Fsimple-sort%2F</url>
    <content type="text"><![CDATA[简单排序冒泡排序 、选择排序 、插入排序 公共代码部分1234567891011121314151617181920212223public class SwapUtils &#123; public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; public static void printArrays(int[] arrs) &#123; StringBuilder sb = new StringBuilder(); if (null == arrs || arrs.length == 0) &#123; System.out.println("Is Empty!"); return; &#125; for (int i = 0; i &lt; arrs.length; i++) &#123; sb.append("," + arrs[i]); &#125; String toPring = sb.append(" ]").toString().replaceFirst(",", ""); System.out.println(toPring); &#125;&#125; 冒泡排序：冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。基本思想 比较相邻的元素。如果第一个比第二个大，就交换他们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对进行循环遍历。最后的元素会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 遍历流程图例 代码实现123456789101112131415public static void bubbleSort(int[] arr) &#123; if (null == arr || arr.length == 0) &#123; return; &#125; //i控制外循环即总共需要将多少个数字进行排序， //j控制内循环即每次循环都会将最大的数排到右边 for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; //如果前面的数字大于后面的数字就将前面的数字和后面的数字进行交换，直接最大的数字被排到最右侧 if (arr[j] &gt; arr[j + 1]) &#123; SwapUtils.swap(arr, j + 1, j); &#125; &#125; &#125;&#125; 冒泡排序的时间复杂度为O(n²) 最快：当输入的数据已经是正序时（都已经是正序了，冒泡排序有何用）。最慢：当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。 选择排序：选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处不占用额外的内存空间。基本思想 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置； 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾； 重复第二步，直到遍历完所有元素，且均排序完毕为止。 遍历流程图例 代码实现1234567891011121314151617181920public static void selectSort(int[] arr) &#123; if (null == arr || arr.length == 0) &#123; return; &#125; // 每一趟循环比较时，min用于存放较小元素的数组下标， // 这样当前批次比较完毕最终存放的就是此趟内最小的元素的下标，避免每次遇到较小元素都要进行交换。 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; if (min != i) &#123; SwapUtils.swap(arr, min, i); &#125; &#125; &#125; 选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。 插入排序：插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。基本思想 将第一待排序序列的第一个元素作为一个有序序列，把第二个元素到最后一个元素当成是未排序序列； 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面） 遍历流程图例 代码实现123456789101112131415161718192021public static void insertSort(int[] arr) &#123; if (null == arr || arr.length == 0) &#123; return; &#125; // 从下标为1的元素开始选择合适的位置插入， // 因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt; arr.length; i++) &#123; // 记录要插入的数据 int tmp = arr[i]; int j = i; // 从已经排序的序列最右边的开始比较，找到比其小的数 while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; // 存在比其小的数，插入 if (j != i) &#123; arr[j] = tmp; &#125; &#125; &#125; 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。时间复杂度为O(n²)，是稳定的排序。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2015%2F03%2F13%2Fsort-algorithm%2F</url>
    <content type="text"><![CDATA[排序算法分类&emsp;&emsp;&emsp;排序算法从排序的效率上分类，主要分四类： 简单排序：冒泡排序 、(直接)选择排序 、(直接)插入排序 ； 高效排序：快速排序 、堆排序 、希尔排序 ； 分治递归思想实现的排序：递归排序 ； 线性排序：计数排序 、桶排序 、基数排序 ；&emsp;&emsp;&emsp;排序算法从排序的方式分类，主要分为五类： 插入排序：直接插入排序 、希尔排序 ； 选择排序：直接选择排序 、堆排序 ； 交换排序：冒泡排序 、快速排序 ； 线性排序：计数排序 、基数排序 、桶排序 ； 递归排序：归并排序 ； 关于时间复杂度： 平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。 线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序； O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序 线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。 关于稳定性 ： 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 名词解释 ： n：数据规模 k：“桶”的个数 In-place：占用常数内存，不占用额外内存 Out-place：占用额外内存 稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同 排序的10种算法如下图例： &emsp;&emsp;&emsp;后续有关博文主要从排序效率上讲解以上4类排序中共10种排序算法思以及使用Java语言的算法实现。 简单排序 高效排序 归并排序 线性排序 参考： 八大基础排序总结 十大经典排序算法]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客简介]]></title>
    <url>%2F2014%2F07%2F22%2Ffirstblog%2F</url>
    <content type="text"><![CDATA[个人博客简介&emsp;&emsp;&emsp;&emsp;作为一枚计科专业的码农，2014年开始从事后端应用开发至今，将日常工作中遇到的问题、个人知识积累、个人见解和“打怪升级”晋级的经验分享于自己的博客，欢迎广大蜀黍来此博客分享自己的“故事”。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;———&emsp;ZhangSunny]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>小记</tag>
      </tags>
  </entry>
</search>
